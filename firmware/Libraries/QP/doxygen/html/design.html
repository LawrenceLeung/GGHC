<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C: 4. Designing an Event-Driven Application</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">QP/C Reference Manual</a>      </li>
      <li class="navelem"><a class="el" href="tutorial_page.html">QP/C Tutorial</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>4. Designing an Event-Driven Application </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p><em>This QP/C Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br/>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em></p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg"/>
</div>
<p>Prev: <a class="el" href="main_function.html">3. The main() Function</a> <br/>
 Next: <a class="el" href="active_objects.html">5. Elaborating State Machines of Active Objects</a></p>
<p>To proceed further with the explanation of the "Fly 'n' Shoot" application, I need to step up to the design level. At this point I need to explain how the application has been decomposed into the active objects, and how these objects exchange events to collectively deliver the functionality of the "Fly 'n'
Shoot" game.</p>
<p>In general, the decomposition of a problem into active objects is not trivial. As usual in any decomposition, your goal is to achieve possibly loose coupling among the active object components (ideally no sharing of any resources), and you also strive for minimizing the communication in terms of the frequency and size of exchanged events.</p>
<p>In the case of the "Fly 'n' Shoot" game, I need first to identify all objects with reactive behavior (i.e. with a state machine). I applied the simplest object-oriented technique of identifying objects, which is to pick the frequently used nouns in the problem specification. From Section <a class="el" href="lets_play.html">2. Let's Play</a>, I identified Ship, Missile, Mines, and Tunnel. However, not every state machine in the system needs to be an active object (with a separate task context, an event queue, and a unique priority level), and merging them is a valid option when performance or space is needed. As an example of this idea, I ended up merging the Mines into the Tunnel active object, whereas I preserved the Mines as independent state machine components of the Tunnel active object. By doing so I applied the "Orthogonal Component" design pattern described in Chapter 5 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>.</p>
<p>The next step in the event-driven application design is assigning responsibilities and resources to the identified active objects. The general design strategy for avoiding sharing of resources is to encapsulate each resource inside a dedicated active object and to let that object manage the resource for the rest of the application. That way, instead of sharing the resource directly, the rest of the application shares the dedicated active object via events.</p>
<p>So, for example, I decided to put the Tunnel active object in charge of the display. Other active objects and state machine components, such as Ship, Missile and Mines, don't draw on the display directly, but rather send events to the Tunnel object with the request to render the Ship, Missile, or Mine bitmaps at the provided (x, y) coordinates of the display.</p>
<p>With some understanding of the responsibilities and resource allocations to active object I can move on to devising the various scenarios of event exchanges among the objects. Perhaps the best instrument to aid the thinking process at this stage is the UML sequence diagram, such as the diagram depicted in <a class="el" href="design.html#F4s1">Figure 4-1</a>. This particular sequence diagram shows the most common event exchange scenarios in the "Fly 'n' Shoot" game (the primary use cases, if you will). The explanation section immediately following the diagram illuminates the interesting points.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>A UML sequence diagram like <a class="el" href="design.html#F4s1">Figure 4-1</a> has two dimensions. Horizontally arranged boxes represent the various objects participating in the scenario whereas heavy boarders indicate active objects. As usual in the UML, the object name in underlined. Time flows down the page along the vertical dashed lines descending from the objects. Events are represented as horizontal arrows originating from the sending object and terminating at the receiving object. Optionally, thin rectangles around instance lines indicate focus of control.</dd></dl>
<p><a class="anchor" id="F4s1"></a> </p>
<div align="center">
<img src="Fig1.04.jpg" alt="Fig1.04.jpg"/>
<p><strong>Figure 4-1 The sequence diagram of the Fly 'n' Shoot game.</strong></p></div>
 <ul>
<li>(1) The <code>TIME_TICK</code> is the most important event in the game. This event is generated by the QF framework from the system time tick interrupt at a rate of 30 times per second, which is needed to drive a smooth animation of the display. Because the <code>TIME_TICK</code> event is of interest to virtually all objects in the application, it is published by the framework to all active objects. (The publish-subscribe event delivery in QF is described in Chapter 6 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>.)</li>
</ul>
<ul>
<li>(2) Upon reception of the <code>TIME_TICK</code> event, the Ship object advances its position by one step and posts the event <code>SHIP_IMG(x, y, bmp)</code> to the Tunnel object. The SHIP_IMG event has parameters x and y, which are the coordinates of the Ship on the display, as well as the bitmap number bmp to draw at these coordinates.</li>
</ul>
<ul>
<li>(3) The Missile object is not in flight yet, so it simply ignores the <code>TIME_TICK</code> event this time.</li>
</ul>
<ul>
<li>(4) The Tunnel object performs the heaviest lifting for the <code>TIME_TICK</code> event. First, Tunnel redraws the entire display from the current frame buffer. This action performed 30 times per second provides the illusion of animation of the display. Next, the Tunnel clears the frame buffer and starts filling it up again for the next time frame. The Tunnel advances the tunnel walls by one step and copies the walls to the frame buffer. The Tunnel also dispatches the <code>TIME_TICK</code> event to all its Mine state machine components.</li>
</ul>
<ul>
<li>(5) Each Mine advances its position by one step and posts the <code>MINE_IMG(x, y, bmp)</code> event to the Tunnel to render the appropriate Mine bitmap at the position <code>(x, y)</code> in the current frame buffer. Mines of type 1 send the bitmap number MINE1_BMP, while mines of type 2 send <code>MINE2_BMP</code>.</li>
</ul>
<ul>
<li>(6) Upon reception of the <code>SHIP_IMG(x, y, bmp)</code> event from the Ship, the Tunnel object renders the specified bitmap in the frame buffer and checks for any collision between the ship bitmap and the tunnel walls. Tunnel also dispatches the original <code>SHIP_IMG(x, y, bmp)</code> event to all active Mines.</li>
</ul>
<ul>
<li>(7) Each Mine determines if the Ship is in collision with that Mine.</li>
</ul>
<ul>
<li>(8) The <code>PLAYER_TRIGGER</code> event is generated when the Player reliably presses the button (button press is debounced). This event is published by the QF framework and is delivered to the Ship and Tunnel objects, which both subscribe to the <code>PLAYER_TRIGGER</code> event.</li>
</ul>
<ul>
<li>(9) Ship generates the <code>MISSILE_FIRE(x, y)</code> event to the Missile object. The parameters of this event are the current <code>(x, y)</code> coordinates of the Ship, which are the starting point for the Missile.</li>
</ul>
<ul>
<li>(10) Tunnel receives the published <code>PLAYER_TRIGGER</code> event as well because Tunnel occasionally needs to start the game or terminate the screen saver mode based upon this stimulus.</li>
</ul>
<ul>
<li>(11) Missile reacts to the <code>MISSILE_FIRE(x, y)</code> event by starting to fly, whereas it sets its initial position from the <code>(x, y)</code> event parameters delivered from the Ship.</li>
</ul>
<ul>
<li>(12) This time around, the <code>TIME_TICK</code> event arrives while Missile is in flight. Missile posts the <code>MISSILE_IMG(x, y, bmp)</code> event to the Table.</li>
</ul>
<ul>
<li>(13) Table renders the Missile bitmap in the current frame buffer and dispatches the <code>MISSILE_IMG(x, y, bmp)</code> event to all the Mines to let the Mines test for the collision with the Missile. This determination depends on the type of the Mine. In this scenario a particular Mine[n] object detects a hit and posts the <code>HIT_MINE(score)</code> event to the Missile. The Mine provides the score earned for destroying this particular mine as the parameter of this event.</li>
</ul>
<ul>
<li>(14) Missile handles the <code>HIT_MINE(score)</code> event by becoming immediately ready to launch again and lets the Mine do the exploding. As I decided to make the Ship responsible for the scorekeeping, the Missile also generates the <code>DESTROYED_MINE(score)</code> event to the Ship, to report the score for destroying the Mine.</li>
</ul>
<ul>
<li>(15) Upon reception of the <code>DESTROYED_MINE(score)</code> event, the Ship updates the score reported by the Missile.</li>
</ul>
<ul>
<li>(16) The Ship object handles the <code>PLAYER_SHIP_MOVE(x, y)</code> event by updating its position from the event parameters.</li>
</ul>
<ul>
<li>(17) When the Tunnel object handles the <code>SHIP_IMG(x, y, bmp_id)</code> event next time around, it detects a collision between the Ship and the tunnel wall. In that case it posts the event <code>HIT_WALL</code> to the Ship.</li>
</ul>
<ul>
<li>(18) The Ship responds to the <code>HIT_WALL</code> event by transitioning to the "exploding" state.</li>
</ul>
<p>Even though the sequence diagram in <a class="el" href="design.html#F4s1">Figure 4-1</a> shows merely some selected scenarios of the "Fly 'n' Shoot" game, I hope that the explanations give you a big picture of how the application works. More importantly, you should start getting the general idea about the thinking process that goes into designing an event-driven system with active objects and events.</p>
<p>Prev: <a class="el" href="main_function.html">3. The main() Function</a> <br/>
 Next: <a class="el" href="active_objects.html">5. Elaborating State Machines of Active Objects</a></p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
</div>
<p> Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.<br/>
 <a href="http://www.state-machine.com">http://www.state-machine.com</a> </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 26 2011 09:40:34 for QP/C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
