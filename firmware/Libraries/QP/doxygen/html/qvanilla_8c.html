<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C: qvanilla.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>qvanilla.c File Reference</h1>  </div>
</div>
<div class="contents">

<p>"vanilla" cooperative kernel, <a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start()</a>, <a class="el" href="qf_8h.html#a361b6756ee8cbca0005e4c3afc4ada5b" title="Stops execution of an active object and removes it from the framework&#39;s supervision.">QActive_stop()</a>, and <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> implementation.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="qf__pkg_8h_source.html">qf_pkg.h</a>&quot;</code><br/>
<code>#include &quot;qassert.h&quot;</code><br/>
</div>
<p><a href="qvanilla_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char const Q_ROM *Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qvanilla_8c.html#af80b99e76774d44c6db8aecc43973965">QF_getPortVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the QF-port version.  <a href="#af80b99e76774d44c6db8aecc43973965"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qvanilla_8c.html#adac7eccb860d910c4e446d3143798bba">QF_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QF initialization.  <a href="#adac7eccb860d910c4e446d3143798bba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qvanilla_8c.html#adf9cb86740bf55c5ad55c1d44fd35921">QF_stop</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Function invoked by the application layer to stop the QF application and return control to the OS/Kernel.  <a href="#adf9cb86740bf55c5ad55c1d44fd35921"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qvanilla_8c.html#a7a41998117b4edb760b754f5ee3f61d5">QF_run</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers control to QF to run the application.  <a href="#a7a41998117b4edb760b754f5ee3f61d5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qvanilla_8c.html#a0123f02b4c1bcf7df2cc0b11dfce8b09">QActive_start</a> (<a class="el" href="struct_q_active.html">QActive</a> *me, uint8_t prio, <a class="el" href="struct_q_event.html">QEvent</a> const *qSto[], uint32_t qLen, void *stkSto, uint32_t stkSize, <a class="el" href="struct_q_event.html">QEvent</a> const *ie)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts execution of an active object and registers the object with the framework.  <a href="#a0123f02b4c1bcf7df2cc0b11dfce8b09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qvanilla_8c.html#a361b6756ee8cbca0005e4c3afc4ada5b">QActive_stop</a> (<a class="el" href="struct_q_active.html">QActive</a> *me)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops execution of an active object and removes it from the framework's supervision.  <a href="#a361b6756ee8cbca0005e4c3afc4ada5b"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>"vanilla" cooperative kernel, <a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start()</a>, <a class="el" href="qf_8h.html#a361b6756ee8cbca0005e4c3afc4ada5b" title="Stops execution of an active object and removes it from the framework&#39;s supervision.">QActive_stop()</a>, and <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> implementation. </p>

<p>Definition in file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0123f02b4c1bcf7df2cc0b11dfce8b09"></a><!-- doxytag: member="qvanilla.c::QActive_start" ref="a0123f02b4c1bcf7df2cc0b11dfce8b09" args="(QActive *me, uint8_t prio, QEvent const *qSto[], uint32_t qLen, void *stkSto, uint32_t stkSize, QEvent const *ie)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>me</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>qSto</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>qLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stkSto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stkSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_q_event.html">QEvent</a> const *&#160;</td>
          <td class="paramname"><em>ie</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts execution of an active object and registers the object with the framework. </p>
<p>The function takes seven arguments. <em>me</em> is a pointer to the active object structure. <em>prio</em> is the priority of the active object. QF allows you to start up to 63 active objects, each one having a unique priority number between 1 and 63 inclusive, where higher numerical values correspond to higher priority (urgency) of the active object relative to the others. <em>qSto</em>[] and <em>qLen</em> arguments are the storage and size of the event queue used by this active object. <em>stkSto</em> and <em>stkSize</em> are the stack storage and size in bytes. Please note that a per-active object stack is used only when the underlying OS requies it. If the stack is not required, or the underlying OS allocates the stack internally, the <em>stkSto</em> should be NULL and/or <em>stkSize</em> should be 0. <em>ie</em> is an optional initialization event that can be used to pass additional startup data to the active object. (Pass NULL if your active object does not expect the initialization event).</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is strongly OS-dependent and must be defined in the QF port to a particular platform.</dd></dl>
<p>The following example shows starting of the Philosopher object when a per-task stack is required: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> Philosopher l_philo[N];              <span class="comment">/* N Philosopher active objects */</span>
<span class="keyword">static</span> <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *l_philQueueSto[N][N];<span class="comment">/* storage for Philo event queues */</span>
<span class="keyword">static</span> <span class="keywordtype">int</span> l_philoStk[N][256]; <span class="comment">/* stacks for the Philosopher active objects */</span>

main() {
    . . .
    <span class="keywordflow">for</span> (n = 0; n &lt; N; ++n) {
        TableEvt ie;        <span class="comment">/* initialization event for the Philosopher HSM */</span>
        ie.philNum = n;
        Philosopher_ctor(&amp;l_philo[n]);
        <a class="code" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start</a>((<a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *)&amp;l_philo[n],       <span class="comment">/* Philosopher number n */</span>
                      (uint8_t)(n*10 + 1),                      <span class="comment">/* priority */</span>
                      l_philoQueueSto[n], <a class="code" href="qevent_8h.html#ad58d2c6dc25f8f0f764eb69faa79eee2">Q_DIM</a>(l_philoQueueSto[n]),<span class="comment">/*queue */</span>
                      l_philoStk[n], <span class="keyword">sizeof</span>(l_philoStk[n]),<span class="comment">/*uC/OS-II stack */</span>
                      (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *)&amp;ie);         <span class="comment">/* initialization event */</span>
    }
    . . .
} 
</pre></div> 
<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00097">97</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

<p>References <a class="el" href="qf_8h_source.html#l00149">QActive::eQueue</a>, <a class="el" href="qf_8h_source.html#l00175">QActive::prio</a>, <a class="el" href="qassert_8h_source.html#l00123">Q_REQUIRE</a>, <a class="el" href="qeq__init_8c_source.html#l00038">QEQueue_init()</a>, <a class="el" href="qf_8h_source.html#l00097">QF_ACTIVE_INIT_</a>, <a class="el" href="qf__act_8c_source.html#l00059">QF_add_()</a>, <a class="el" href="qs_8h_source.html#l01015">QS_FLUSH</a>, and <a class="el" href="qf_8h_source.html#l00137">QActive::super</a>.</p>

</div>
</div>
<a class="anchor" id="a361b6756ee8cbca0005e4c3afc4ada5b"></a><!-- doxytag: member="qvanilla.c::QActive_stop" ref="a361b6756ee8cbca0005e4c3afc4ada5b" args="(QActive *me)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QActive_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_q_active.html">QActive</a> *&#160;</td>
          <td class="paramname"><em>me</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops execution of an active object and removes it from the framework's supervision. </p>
<p>The preferred way of calling this function is from within the active object that needs to stop. In other words, an active object should stop itself rather than being stopped by some other entity. This policy works best, because only the active object itself "knows" when it has reached the appropriate state for the shutdown.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is strongly OS-dependent and should be defined in the QF port to a particular platform. This function is optional in embedded systems where active objects never need to be stopped. </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00114">114</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

<p>References <a class="el" href="qf__act_8c_source.html#l00079">QF_remove_()</a>.</p>

</div>
</div>
<a class="anchor" id="af80b99e76774d44c6db8aecc43973965"></a><!-- doxytag: member="qvanilla.c::QF_getPortVersion" ref="af80b99e76774d44c6db8aecc43973965" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const Q_ROM* Q_ROM_VAR QF_getPortVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the QF-port version. </p>
<p>This function returns constant version string in the format x.y.zz, where x (one digit) is the major version, y (one digit) is the minor version, and zz (two digits) is the maintenance release version. An example of the QF-port version string is "1.1.03".</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a927f2df95064369af767d9ee268ac7e8" title="Returns the QF version.">QF_getVersion()</a> </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00048">48</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00063">Q_ROM</a>, and <a class="el" href="qevent_8h_source.html#l00081">Q_ROM_VAR</a>.</p>

</div>
</div>
<a class="anchor" id="adac7eccb860d910c4e446d3143798bba"></a><!-- doxytag: member="qvanilla.c::QF_init" ref="adac7eccb860d910c4e446d3143798bba" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QF initialization. </p>
<p>This function initializes QF and must be called exactly once before any other QF function. </p>

<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00053">53</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7a41998117b4edb760b754f5ee3f61d5"></a><!-- doxytag: member="qvanilla.c::QF_run" ref="a7a41998117b4edb760b754f5ee3f61d5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_run </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfers control to QF to run the application. </p>
<p><a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> is typically called from your startup code after you initialize the QF and start at least one active object with <a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start()</a>. Also, QF_start() call must precede the transfer of control to <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a>, but some QF ports might call QF_start() from <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a>. <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> typically never returns to the caller.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is strongly platform-dependent and is not implemented in the QF, but either in the QF port or in the Board Support Package (BSP) for the given application. All QF ports must implement <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a>.</dd>
<dd>
When the Quantum Kernel (QK) is used as the underlying real-time kernel for the QF, all platfrom dependencies are handled in the QK, so no porting of QF is necessary. In other words, you only need to recompile the QF platform-independent code with the compiler for your platform, but you don't need to provide any platform-specific implementation (so, no qf_port.c file is necessary). Moreover, QK implements the function <a class="el" href="qf_8h.html#a7a41998117b4edb760b754f5ee3f61d5" title="Transfers control to QF to run the application.">QF_run()</a> in a platform-independent way, in the modile <a class="el" href="qk_8c.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK_getVersion(), QF_init(), QF_run(), QF_stop(), QActive_start(), QActive_stop() implementations.">qk.c</a>. </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00062">62</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

<p>References <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>, <a class="el" href="qf__act_8c_source.html#l00041">QF_active_</a>, <a class="el" href="qf_8h_source.html#l00102">QF_ACTIVE_DISPATCH_</a>, <a class="el" href="qf__gc_8c_source.html#l00040">QF_gc()</a>, <a class="el" href="qf__pkg_8h_source.html#l00060">QF_INT_LOCK_</a>, <a class="el" href="qf__pkg_8h_source.html#l00049">QF_INT_LOCK_KEY_</a>, <a class="el" href="qf__pkg_8h_source.html#l00071">QF_INT_UNLOCK_</a>, <a class="el" href="qf_8h.html#a189a6d2ece787717c81fbf51fd180732">QF_onStartup()</a>, <a class="el" href="qpset_8h_source.html#l00160">QPSet64_findMax</a>, <a class="el" href="qpset_8h_source.html#l00132">QPSet64_notEmpty</a>, <a class="el" href="qpset_8h_source.html#l00081">QPSet8_findMax</a>, <a class="el" href="qpset_8h_source.html#l00060">QPSet8_notEmpty</a>, and <a class="el" href="qf_8h_source.html#l00137">QActive::super</a>.</p>

</div>
</div>
<a class="anchor" id="adf9cb86740bf55c5ad55c1d44fd35921"></a><!-- doxytag: member="qvanilla.c::QF_stop" ref="adf9cb86740bf55c5ad55c1d44fd35921" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QF_stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Function invoked by the application layer to stop the QF application and return control to the OS/Kernel. </p>
<p>This function stops the QF application. After calling this function, QF attempts to gracefully stop the application. This graceful shutdown might take some time to complete. The typical use of this funcition is for terminating the QF application to return back to the operating system or for handling fatal errors that require shutting down (and possibly re-setting) the system.</p>
<p>This function is strongly platform-specific and is not implemented in the QF, but either in the QF port or in the Board Support Package (BSP) for the given application. Some QF ports might not require implementing <a class="el" href="qf_8h.html#adf9cb86740bf55c5ad55c1d44fd35921" title="Function invoked by the application layer to stop the QF application and return control to the OS/Ker...">QF_stop()</a> at all, because many embedded applications don't have anything to exit to.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0" title="Cleanup QF callback.">QF_onCleanup()</a> </dd></dl>

<p>Definition at line <a class="el" href="qvanilla_8c_source.html#l00057">57</a> of file <a class="el" href="qvanilla_8c_source.html">qvanilla.c</a>.</p>

<p>References <a class="el" href="qf_8h.html#a5d7e181f2e679e1fa77c1e915fbee3e0">QF_onCleanup()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 26 2011 09:40:33 for QP/C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
