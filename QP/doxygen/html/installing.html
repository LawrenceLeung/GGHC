<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C: 1. Installing QP/C and Building QP Libraries and Applications</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">QP/C Reference Manual</a>      </li>
      <li class="navelem"><a class="el" href="tutorial_page.html">QP/C Tutorial</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>1. Installing QP/C and Building QP Libraries and Applications </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p><em>This QP/C Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br/>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em></p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg"/>
</div>
<p>Prev: <a class="el" href="tutorial_page.html">QP/C Tutorial</a> <br/>
 Next: <a class="el" href="lets_play.html">2. Let's Play</a></p>
<p>QP/C is distributed in a simple platform-independent ZIP file, or in a self-extracting Windows executable. Either way, installing QP requires simply decompressing the provided archive into a directory of your choice (e.g., <code>&lt;qpc&gt;</code> for QP/C). The Section <a class="el" href="files_page.html">Directories and Files in the QP/C Distribution</a> describes the directories and files included in the standard QP/C distribution.</p>
<p>Specifically to the "Fly 'n' Shoot" example, the companion code contains two versions of the game. I provide a DOS version for the standard Windows-based PC (see <a class="el" href="lets_play.html#F2s1">Figure 2-1</a>) so that you don't need any special embedded board to play the game and experiment with the code.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>I've chosen the legacy 16-bit DOS platform because it allows programming a standard PC at the bare-metal level. Without leaving your desktop, you can work with interrupts, directly manipulate CPU registers, and directly access the I/O space. No other modern 32-bit development environment for the standard PC allows this much so easily. The ubiquitous PC running under DOS (or a DOS console within any variant of Windows) is as close as it gets to emulate embedded software development on the commodity 80x86 hardware. Additionally, you can use free, mature tools, such as the Open Watcom C/C++ compiler.</dd></dl>
<p>I also provide an embedded version for the inexpensive ARM Corterx-M3-based ARM Cortex-M3 LM3S811 evaluation kit from Luminary Micro (see <a class="el" href="lets_play.html#F2s2">Figure 2-2</a>). Both the PC and ARM-Cortex versions use the exact same source code for all application components and differ only in the Board Support Package (BSP).</p>
<h2><a class="anchor" id="building_lib"></a>
1.1 Building QP Libraries</h2>
<dl class="note"><dt><b>Note:</b></dt><dd>The pre-compiled QP libraries are provided in the standard QP distribution (see <a class="el" href="files_page.html">Directories and Files in the QP/C Distribution</a>), so you can start experimenting with all examples without building the QP libraries. However, if you want to re-build the QP libraries, this section provides the details.</dd></dl>
<p><a class="el" href="installing.html#F1s1">Figure 1-1</a> illustrates the steps required to build the QF library. The process of building other QP components, such as QEP or QK, is essentially identical. The key point of the design is that all platform-independent QF source files include the same <code>qf_port.h</code> header file as the application source files (see <a class="el" href="installing.html#F1s1">Figure 1-1</a>). At this point you can clearly see that the Platfrom Abstraction Layer (PAL) provided in QP plays the dual role of facilitating the porting of QP as well as using it in the applications. <a class="el" href="installing.html#F1s1">Figure 1-1</a> shows also that every QP component, such as QF, can contain a platform-specific source file (<code>qf_port.c</code> in this case). The platform-specific source file is optional and many ports don't require it.</p>
<p><a class="anchor" id="F1s1"></a> </p>
<div align="center">
<img src="Fig8.02.jpg" alt="Fig8.02.jpg"/>
<p><strong>Figure 1-1 Building the QF library.</strong></p></div>
<p> The standard QP ports often contain a simple <code>make.bat</code> script or a <code>Makefile</code> for building all the QP libraries for the port. You typically can choose the build configuration by providing a target to the <code>make.bat</code> script or to the <code>Makefile</code>. The default target is "dbg". Other possible targets are "rel", and "spy". The following table summarizes the targets accepted by the <code>make.bat</code> scripts or the <code>Makefiles</code>.</p>
<table  summary="Build Targets" cellspacing="4" cellpadding="1" border="0" align="center" valign="middle">
<tr bgcolor="#c8cedc">
<td><b>&#160;Build Configuration</b> </td><td><p class="starttd"><b>&#160;Build Command</b> </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#ffffcc">
<td>&#160;Debug&#160; </td><td><p class="starttd">make </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#ffffdd">
<td>&#160;Release&#160; </td><td><p class="starttd">make rel </p>
<p class="endtd"></p>
</td></tr>
<tr bgcolor="#ffffcc">
<td>&#160;Spy&#160; </td><td>make spy  </td></tr>
</table>
<dl class="note"><dt><b>Note:</b></dt><dd>All QP components are designed to be deployed in fine-granularity object libraries. QP libraries allow the linker to eliminate any unreferenced QP code at link time, which results in automatic scaling of every QP component for a wide range of applications. This approach eliminates the need to manually configure and recompile the QP source code for each application at hand.</dd></dl>
<h2><a class="anchor" id="building_app"></a>
1.2 Building QP Applications</h2>
<dl class="note"><dt><b>Note:</b></dt><dd>The standard QP distribution contains pre-compiled examples (see <a class="el" href="files_page.html">Directories and Files in the QP/C Distribution</a>), so you can start experimenting with all examples without building them. However, if you want to re-build the QP examples, this section provides the details.</dd></dl>
<p><a class="el" href="installing.html#F1s2">Figure 1-2</a> shows the process of building a QP application. Each QP component requires inclusion of only one platform-specific header file and linking one platform-specific library. For example, to use the QF real-time framework, you need to include the <code>qf_port.h</code> header file and you need to link the <code>qf.lib</code> library file from the specific QP port directory. It really doesn't get any simpler than that.</p>
<p><a class="anchor" id="F1s2"></a> </p>
<div align="center">
<img src="Fig8.01.jpg" alt="Fig8.01.jpg"/>
<p><strong>Figure 1-2 Building a QP-based Application.</strong></p></div>
<p> The QP port you are using is determined by the directory branch in which the <code>qf_port.h</code> header file and the QF library file are located. Section <a class="el" href="files_page.html">Directories and Files in the QP/C Distribution</a> shows some examples of such port directories. Typically you need to instruct the C/C++ compiler to include header files from the specific QP port directory and also from the platform-independent include directory <code>&lt;qpc&gt;\include\</code>. I strongly discourage hard-coding full path-names of the include files in your source code. You should simply include the QP port header file (<code>#include "qf_port.h"</code>) without any path. Then you specify to the compiler to search the QP port directory for include files, typically through the <code>-I</code> option.</p>
<p>Prev: <a class="el" href="tutorial_page.html">QP/C Tutorial</a> <br/>
 Next: <a class="el" href="lets_play.html">2. Let's Play</a></p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
</div>
<p> Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.<br/>
 <a href="http://www.state-machine.com">http://www.state-machine.com</a> </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 26 2011 09:40:34 for QP/C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
