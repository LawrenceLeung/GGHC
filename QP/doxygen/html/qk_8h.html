<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C: qk.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>qk.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>QK/C platform-independent public interface.  
<a href="#_details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="qequeue_8h_source.html">qequeue.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qmpool_8h_source.html">qmpool.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="qpset_8h_source.html">qpset.h</a>&quot;</code><br/>
<code>#include &quot;qs_port.h&quot;</code><br/>
</div>
<p><a href="qk_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#aee19c1d6e860d59dda6e539852b99dbe">QF_EQUEUE_TYPE</a>&#160;&#160;&#160;<a class="el" href="struct_q_e_queue.html">QEQueue</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro defines the type of the event queue used for the active objects.  <a href="#aee19c1d6e860d59dda6e539852b99dbe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ae2426ed9b8543cbbccde98023d7773a7">QACTIVE_EQUEUE_WAIT_</a>(me_)&#160;&#160;&#160;Q_ASSERT((me_)-&gt;eQueue.frontEvt != (<a class="el" href="struct_q_event.html">QEvent</a> *)0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should block the calling task when the QF native queue is empty.  <a href="#ae2426ed9b8543cbbccde98023d7773a7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ad4ad4a29e36b9ad8e2aff0e7074c2a68">QACTIVE_EQUEUE_SIGNAL_</a>(me_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should signal the active object task that an event has just arrived.  <a href="#ad4ad4a29e36b9ad8e2aff0e7074c2a68"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a61cb9dfde96112710d74f08620875427">QACTIVE_EQUEUE_ONEMPTY_</a>(me_)&#160;&#160;&#160;QPSet64_remove(&amp;<a class="el" href="qk_8c.html#aa76ad1523d8a245329aa8505ee3fe778">QK_readySet_</a>, (me_)-&gt;prio)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining the action QF should take when the native QF event queue becomes empty.  <a href="#a61cb9dfde96112710d74f08620875427"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ab786be96ee118929bfb4dcd51d3acce5">QF_EPOOL_TYPE_</a>&#160;&#160;&#160;<a class="el" href="struct_q_m_pool.html">QMPool</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This macro defines the type of the event pool used in this QF port.  <a href="#ab786be96ee118929bfb4dcd51d3acce5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#af536ec576d2f03b68bcf38ca0c8b918d">QF_EPOOL_INIT_</a>(p_, poolSto_, poolSize_, evtSize_)&#160;&#160;&#160;QMPool_init(&amp;(p_), poolSto_, poolSize_, evtSize_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining the event pool initialization.  <a href="#af536ec576d2f03b68bcf38ca0c8b918d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a920e9b4f47e69079a12bf79a3c43a058">QF_EPOOL_EVENT_SIZE_</a>(p_)&#160;&#160;&#160;((p_).blockSize)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should obtain the event pool block-size.  <a href="#a920e9b4f47e69079a12bf79a3c43a058"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#abb96d6c572a8d24921a1aa2cbddfea8c">QF_EPOOL_GET_</a>(p_, e_)&#160;&#160;&#160;((e_) = (<a class="el" href="struct_q_event.html">QEvent</a> *)QMPool_get(&amp;(p_)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should obtain an event <em>e_</em> from the event pool <em>p_</em>.  <a href="#abb96d6c572a8d24921a1aa2cbddfea8c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ac34ffaba95ab38473684fdfeaef17d9a">QF_EPOOL_PUT_</a>(p_, e_)&#160;&#160;&#160;(QMPool_put(&amp;(p_), (e_)))</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Platform-dependent macro defining how QF should return an event <em>e_</em> to the event pool <em>p_</em>.  <a href="#ac34ffaba95ab38473684fdfeaef17d9a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK Mutex type.  <a href="#a13b8c3b1b8a65b6e521505922f643104"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#ae1fa4705c311e29699a0164a20362bf1">QK_init</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK initialization.  <a href="#ae1fa4705c311e29699a0164a20362bf1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61">QK_onIdle</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK idle callback (customized in BSPs for QK)  <a href="#a667daad24b172e782fe4e2b5b06fbf61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char const Q_ROM *Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#adb582ced35db744615453884461a03e0">QK_getVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get the current QK version number string  <a href="#adb582ced35db744615453884461a03e0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">char const Q_ROM *Q_ROM_VAR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a1c0552f5268496a3fba67424fe9accb0">QK_getPortVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the QK-port version.  <a href="#a1c0552f5268496a3fba67424fe9accb0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2">QK_mutexLock</a> (uint8_t prioCeiling)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK priority-ceiling mutex lock.  <a href="#a02a27011a5aa955b140cd749b64b16e2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a">QK_mutexUnlock</a> (<a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a> mutex)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">QK priority-ceiling mutex unlock.  <a href="#a9f4ddf313bcfd3cac43225f2a35e278a"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_q_p_set64.html">QPSet64</a> volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#aa76ad1523d8a245329aa8505ee3fe778">QK_readySet_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a81b2832f194ed3d09803c8a4e86a1a23">QK_currPrio_</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t volatile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="qk_8h.html#a2c90cb8ede2a3fa89616f23b7df258de">QK_intNest_</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>QK/C platform-independent public interface. </p>
<p>This header file must be included directly or indirectly in all modules (*.c files) that use QK/C. </p>

<p>Definition in file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a61cb9dfde96112710d74f08620875427"></a><!-- doxytag: member="qk.h::QACTIVE_EQUEUE_ONEMPTY_" ref="a61cb9dfde96112710d74f08620875427" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QACTIVE_EQUEUE_ONEMPTY_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td>&#160;&#160;&#160;QPSet64_remove(&amp;<a class="el" href="qk_8c.html#aa76ad1523d8a245329aa8505ee3fe778">QK_readySet_</a>, (me_)-&gt;prio)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining the action QF should take when the native QF event queue becomes empty. </p>
<p>The macro is necessary only when the native QF event queue is used. The signaling of task involves unblocking the task if it is blocked.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>QACTIVE_EQUEUE_ONEMPTY_ is called from a critical section. It should not leave the critical section.</dd>
<dd>
This is just an example of QACTIVE_EQUEUE_ONEMPTY_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00152">152</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4ad4a29e36b9ad8e2aff0e7074c2a68"></a><!-- doxytag: member="qk.h::QACTIVE_EQUEUE_SIGNAL_" ref="ad4ad4a29e36b9ad8e2aff0e7074c2a68" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QACTIVE_EQUEUE_SIGNAL_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="qpset_8h.html#aebc824af496448fd68605070404d7c9d" title="insert element n_ into the set me_, n_= 1..64">QPSet64_insert</a>(&amp;<a class="code" href="qk_8h.html#aa76ad1523d8a245329aa8505ee3fe778">QK_readySet_</a>, (me_)-&gt;prio); \
        <span class="keywordflow">if</span> (<a class="code" href="qk_8h.html#a2c90cb8ede2a3fa89616f23b7df258de">QK_intNest_</a> == (uint8_t)0) { \
            QK_SCHEDULE_(); \
        } \
        <span class="keywordflow">else</span> ((<span class="keywordtype">void</span>)0)
</pre></div>
<p>Platform-dependent macro defining how QF should signal the active object task that an event has just arrived. </p>
<p>The macro is necessary only when the native QF event queue is used. The signaling of task involves unblocking the task if it is blocked.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>QACTIVE_EQUEUE_SIGNAL_ is called from a critical section. It might leave the critical section internally, but must restore the critical section before exiting to the caller.</dd>
<dd>
This is just an example of QACTIVE_EQUEUE_SIGNAL_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00132">132</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qa__fifo_8c_source.html#l00043">QActive_postFIFO()</a>, and <a class="el" href="qa__lifo_8c_source.html#l00043">QActive_postLIFO()</a>.</p>

</div>
</div>
<a class="anchor" id="ae2426ed9b8543cbbccde98023d7773a7"></a><!-- doxytag: member="qk.h::QACTIVE_EQUEUE_WAIT_" ref="ae2426ed9b8543cbbccde98023d7773a7" args="(me_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QACTIVE_EQUEUE_WAIT_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">me_</td><td>)</td>
          <td>&#160;&#160;&#160;Q_ASSERT((me_)-&gt;eQueue.frontEvt != (<a class="el" href="struct_q_event.html">QEvent</a> *)0)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should block the calling task when the QF native queue is empty. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QACTIVE_EQUEUE_WAIT_ for the QK-port of QF. QK never activates a task that has no events to process, so in this case the macro asserts that the queue is not empty. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00104">104</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qa__get___8c_source.html#l00043">QActive_get_()</a>.</p>

</div>
</div>
<a class="anchor" id="a920e9b4f47e69079a12bf79a3c43a058"></a><!-- doxytag: member="qk.h::QF_EPOOL_EVENT_SIZE_" ref="a920e9b4f47e69079a12bf79a3c43a058" args="(p_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EPOOL_EVENT_SIZE_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_</td><td>)</td>
          <td>&#160;&#160;&#160;((p_).blockSize)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should obtain the event pool block-size. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_EVENT_SIZE_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00184">184</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__new_8c_source.html#l00040">QF_new_()</a>, and <a class="el" href="qf__pool_8c_source.html#l00044">QF_poolInit()</a>.</p>

</div>
</div>
<a class="anchor" id="abb96d6c572a8d24921a1aa2cbddfea8c"></a><!-- doxytag: member="qk.h::QF_EPOOL_GET_" ref="abb96d6c572a8d24921a1aa2cbddfea8c" args="(p_, e_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EPOOL_GET_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;((e_) = (<a class="el" href="struct_q_event.html">QEvent</a> *)QMPool_get(&amp;(p_)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should obtain an event <em>e_</em> from the event pool <em>p_</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_GET_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00193">193</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__new_8c_source.html#l00040">QF_new_()</a>.</p>

</div>
</div>
<a class="anchor" id="af536ec576d2f03b68bcf38ca0c8b918d"></a><!-- doxytag: member="qk.h::QF_EPOOL_INIT_" ref="af536ec576d2f03b68bcf38ca0c8b918d" args="(p_, poolSto_, poolSize_, evtSize_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EPOOL_INIT_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">poolSto_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">poolSize_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">evtSize_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;QMPool_init(&amp;(p_), poolSto_, poolSize_, evtSize_)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining the event pool initialization. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_INIT_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00174">174</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__pool_8c_source.html#l00044">QF_poolInit()</a>.</p>

</div>
</div>
<a class="anchor" id="ac34ffaba95ab38473684fdfeaef17d9a"></a><!-- doxytag: member="qk.h::QF_EPOOL_PUT_" ref="ac34ffaba95ab38473684fdfeaef17d9a" args="(p_, e_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EPOOL_PUT_</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">p_, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">e_&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(QMPool_put(&amp;(p_), (e_)))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Platform-dependent macro defining how QF should return an event <em>e_</em> to the event pool <em>p_</em>. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of QF_EPOOL_PUT_ for the QK-port of QF. In other QF ports you need to define the macro appropriately for the underlying kernel/OS you're using. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00202">202</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

<p>Referenced by <a class="el" href="qf__gc_8c_source.html#l00040">QF_gc()</a>.</p>

</div>
</div>
<a class="anchor" id="ab786be96ee118929bfb4dcd51d3acce5"></a><!-- doxytag: member="qk.h::QF_EPOOL_TYPE_" ref="ab786be96ee118929bfb4dcd51d3acce5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EPOOL_TYPE_&#160;&#160;&#160;<a class="el" href="struct_q_m_pool.html">QMPool</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro defines the type of the event pool used in this QF port. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of the macro definition. Typically, you need to define it in the specific QF port file (qf_port.h). In case of QK, which always depends on the native QF memory pool, this macro is defined at the level of the platform-independent interface <a class="el" href="qk_8h.html" title="QK/C platform-independent public interface.">qk.h</a>. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00166">166</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<a class="anchor" id="aee19c1d6e860d59dda6e539852b99dbe"></a><!-- doxytag: member="qk.h::QF_EQUEUE_TYPE" ref="aee19c1d6e860d59dda6e539852b99dbe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define QF_EQUEUE_TYPE&#160;&#160;&#160;<a class="el" href="struct_q_e_queue.html">QEQueue</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This macro defines the type of the event queue used for the active objects. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This is just an example of the macro definition. Typically, you need to define it in the specific QF port file (qf_port.h). In case of QK, which always depends on the native QF queue, this macro is defined at the level of the platform-independent interface <a class="el" href="qk_8h.html" title="QK/C platform-independent public interface.">qk.h</a>. </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00055">55</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a13b8c3b1b8a65b6e521505922f643104"></a><!-- doxytag: member="qk.h::QMutex" ref="a13b8c3b1b8a65b6e521505922f643104" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint8_t <a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK Mutex type. </p>
<p>QMutex represents the priority-ceiling mutex available in QK. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a> </dd>
<dd>
<a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a> </dd></dl>

<p>Definition at line <a class="el" href="qk_8h_source.html#l00253">253</a> of file <a class="el" href="qk_8h_source.html">qk.h</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a1c0552f5268496a3fba67424fe9accb0"></a><!-- doxytag: member="qk.h::QK_getPortVersion" ref="a1c0552f5268496a3fba67424fe9accb0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const Q_ROM* Q_ROM_VAR QK_getPortVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the QK-port version. </p>
<p>This function returns constant version string in the format x.y.zz, where x (one digit) is the major version, y (one digit) is the minor version, and zz (two digits) is the maintenance release version. An example of the QK-port version string is "1.1.03".</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qk_8h.html#adb582ced35db744615453884461a03e0" title="get the current QK version number string">QK_getVersion()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="adb582ced35db744615453884461a03e0"></a><!-- doxytag: member="qk.h::QK_getVersion" ref="adb582ced35db744615453884461a03e0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char const Q_ROM* Q_ROM_VAR QK_getVersion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get the current QK version number string </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>version of the QK as a constant 6-character string of the form x.y.zz, where x is a 1-digit major version number, y is a 1-digit minor version number, and zz is a 2-digit release number.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="qk_8h.html#a1c0552f5268496a3fba67424fe9accb0" title="Returns the QK-port version.">QK_getPortVersion()</a> </dd></dl>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00054">54</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

<p>References <a class="el" href="qevent_8h_source.html#l00063">Q_ROM</a>, <a class="el" href="qevent_8h_source.html#l00081">Q_ROM_VAR</a>, and <a class="el" href="qevent_8h_source.html#l00047">QP_VERSION</a>.</p>

</div>
</div>
<a class="anchor" id="ae1fa4705c311e29699a0164a20362bf1"></a><!-- doxytag: member="qk.h::QK_init" ref="ae1fa4705c311e29699a0164a20362bf1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QK_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK initialization. </p>
<p><a class="el" href="qk_8h.html#ae1fa4705c311e29699a0164a20362bf1" title="QK initialization.">QK_init()</a> is called from <a class="el" href="qf_8h.html#adac7eccb860d910c4e446d3143798bba" title="QF initialization.">QF_init()</a> in <a class="el" href="qk_8c.html" title="QK_readySet_, QK_currPrio_, and QK_intNest_ definitions and QK_getVersion(), QF_init(), QF_run(), QF_stop(), QActive_start(), QActive_stop() implementations.">qk.c</a>. This function is defined in the QK ports. </p>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00067">QF_init()</a>.</p>

</div>
</div>
<a class="anchor" id="a02a27011a5aa955b140cd749b64b16e2"></a><!-- doxytag: member="qk.h::QK_mutexLock" ref="a02a27011a5aa955b140cd749b64b16e2" args="(uint8_t prioCeiling)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a> QK_mutexLock </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>prioCeiling</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK priority-ceiling mutex lock. </p>
<p>Lock the QK scheduler up to the priority level <em>prioCeiling</em>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should be always paired with <a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a>. The code between <a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a> and <a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a> should be kept to the minimum.</dd></dl>
<div class="fragment"><pre class="fragment">    <a class="code" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104" title="QK Mutex type.">QMutex</a> mux;
    . . .
    mux = <a class="code" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock</a>(PRIO_CEILING);

    <span class="comment">/* access the shared resource */</span>

    <a class="code" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock</a>(mux);

    . . . 
</pre></div> 
<p>Definition at line <a class="el" href="qk__mutex_8c_source.html#l00047">47</a> of file <a class="el" href="qk__mutex_8c_source.html">qk_mutex.c</a>.</p>

<p>References <a class="el" href="qk__mutex_8c_source.html#l00044">QK_ceilingPrio_</a>, <a class="el" href="qs_8h_source.html#l00713">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00725">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00108">QS_QK_MUTEX_LOCK</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00730">QS_U8_</a>.</p>

</div>
</div>
<a class="anchor" id="a9f4ddf313bcfd3cac43225f2a35e278a"></a><!-- doxytag: member="qk.h::QK_mutexUnlock" ref="a9f4ddf313bcfd3cac43225f2a35e278a" args="(QMutex mutex)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QK_mutexUnlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104">QMutex</a>&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK priority-ceiling mutex unlock. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function should be always paired with <a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a>. The code between <a class="el" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock()</a> and <a class="el" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock()</a> should be kept to the minimum.</dd></dl>
<div class="fragment"><pre class="fragment">    <a class="code" href="qk_8h.html#a13b8c3b1b8a65b6e521505922f643104" title="QK Mutex type.">QMutex</a> mux;
    . . .
    mux = <a class="code" href="qk_8h.html#a02a27011a5aa955b140cd749b64b16e2" title="QK priority-ceiling mutex lock.">QK_mutexLock</a>(PRIO_CEILING);

    <span class="comment">/* access the shared resource */</span>

    <a class="code" href="qk_8h.html#a9f4ddf313bcfd3cac43225f2a35e278a" title="QK priority-ceiling mutex unlock.">QK_mutexUnlock</a>(mux);

    . . . 
</pre></div> 
<p>Definition at line <a class="el" href="qk__mutex_8c_source.html#l00066">66</a> of file <a class="el" href="qk__mutex_8c_source.html">qk_mutex.c</a>.</p>

<p>References <a class="el" href="qk__mutex_8c_source.html#l00044">QK_ceilingPrio_</a>, <a class="el" href="qs_8h_source.html#l00713">QS_BEGIN_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00725">QS_END_NOLOCK_</a>, <a class="el" href="qs_8h_source.html#l00109">QS_QK_MUTEX_UNLOCK</a>, <a class="el" href="qs_8h_source.html#l00175">QS_TIME_</a>, and <a class="el" href="qs_8h_source.html#l00730">QS_U8_</a>.</p>

</div>
</div>
<a class="anchor" id="a667daad24b172e782fe4e2b5b06fbf61"></a><!-- doxytag: member="qk.h::QK_onIdle" ref="a667daad24b172e782fe4e2b5b06fbf61" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void QK_onIdle </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>QK idle callback (customized in BSPs for QK) </p>
<p><a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a> is called continously by the QK idle loop. This callback gives the application an opportunity to enter a power-saving CPU mode, or perform some other idle processing.</p>
<dl class="note"><dt><b>Note:</b></dt><dd><a class="el" href="qk_8h.html#a667daad24b172e782fe4e2b5b06fbf61" title="QK idle callback (customized in BSPs for QK)">QK_onIdle()</a> is invoked with interrupts unlocked and must also return with interrupts unlocked.</dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd>QF_onIdle() </dd></dl>

<p>Referenced by <a class="el" href="qk_8c_source.html#l00076">QF_run()</a>.</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="a81b2832f194ed3d09803c8a4e86a1a23"></a><!-- doxytag: member="qk.h::QK_currPrio_" ref="a81b2832f194ed3d09803c8a4e86a1a23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t volatile <a class="el" href="qk_8c.html#a81b2832f194ed3d09803c8a4e86a1a23">QK_currPrio_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>current task/interrupt priority </p>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00048">48</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2c90cb8ede2a3fa89616f23b7df258de"></a><!-- doxytag: member="qk.h::QK_intNest_" ref="a2c90cb8ede2a3fa89616f23b7df258de" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t volatile <a class="el" href="qk_8c.html#a2c90cb8ede2a3fa89616f23b7df258de">QK_intNest_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>interrupt nesting level </p>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00049">49</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa76ad1523d8a245329aa8505ee3fe778"></a><!-- doxytag: member="qk.h::QK_readySet_" ref="aa76ad1523d8a245329aa8505ee3fe778" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_q_p_set64.html">QPSet64</a> volatile <a class="el" href="qk_8c.html#aa76ad1523d8a245329aa8505ee3fe778">QK_readySet_</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>QK ready-set </p>

<p>Definition at line <a class="el" href="qk_8c_source.html#l00045">45</a> of file <a class="el" href="qk_8c_source.html">qk.c</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 26 2011 09:40:33 for QP/C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
