<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C: 6. Defining Event Signals and Event Parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">QP/C Reference Manual</a>      </li>
      <li class="navelem"><a class="el" href="tutorial_page.html">QP/C Tutorial</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>6. Defining Event Signals and Event Parameters </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p><em>This QP/C Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br/>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em></p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg"/>
</div>
<p>Prev: <a class="el" href="active_objects.html">5. Elaborating State Machines of Active Objects</a> <br/>
 Next: <a class="el" href="coding_hsm.html">7. Coding Hierarchical State Machines</a></p>
<p>The key events in the "Fly 'n' Shoot" game have been identified in the sequence diagram in <a class="el" href="design.html#F4s1">Figure 4-1</a>. Other events have been invented during the state machine design stage. In any case, you must have noticed that events consist really of two parts. The part of the event called the signal conveys the type of the occurrence (what happened). For example, the <code>TIME_TICK</code> signal conveys the arrival of a time tick, while <code>PLAYER_SHIP_MOVE</code> signal conveys that the player wants to move the Ship. An event can also contain additional quantitative information about the occurrence in form of event parameters. For example, the <code>PLAYER_SHIP_MOVE</code> signal is accompanied by the parameters <code>(x, y)</code> that contain the quantitative information as to where exactly to move the Ship. In QP, events are represented as instances of the <a class="el" href="struct_q_event.html" title="Event structure.">QEvent</a> structure provided by the framework. Specifically, the <a class="el" href="struct_q_event.html" title="Event structure.">QEvent</a> structure contains the member sig, to represent the signal of that event. Event parameters are added in the process of inheritance, as described in the sidebar <a class="el" href="derivation.html">Encapsulation and Single Inheritance in C</a>.</p>
<h2><a class="anchor" id="enumerating"></a>
6.1 Enumerating Event Signals and Defining Event Parameters</h2>
<p>Because events are explicitly shared among most of the application components, it is convenient to declare them in the separate header file game.h shown <a class="el" href="events.html#L6s1">Listing 6-1</a>. The explanation section immediately following the listing illuminates the interesting points.</p>
<p><a class="anchor" id="L6s1"></a> <b>Listing 6-1 Signals, event structures, and active object interfaces defined in file game.h.</b> </p>
<div class="fragment"><pre class="fragment"> (1) <span class="keyword">enum</span> GameSignals {                              <span class="comment">/* signals used in the game */</span>
 (2)     TIME_TICK_SIG = <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074a6b922ebd3f2429b5b5e7b411675fda06">Q_USER_SIG</a>,                  <span class="comment">/* published from tick ISR */</span>
         PLAYER_TRIGGER_SIG, <span class="comment">/* published by Player (ISR) to trigger the Missile */</span>
         PLAYER_QUIT_SIG,          <span class="comment">/* published by Player (ISR) to quit the game */</span>
         GAME_OVER_SIG,          <span class="comment">/* published by Ship when it finishes exploding */</span>
         <span class="comment">/* insert other published signals here ... */</span>
 (3)     MAX_PUB_SIG,                               <span class="comment">/* the last published signal */</span>

         PLAYER_SHIP_MOVE_SIG,  <span class="comment">/* posted by Player (ISR) to the Ship to move it */</span>
         BLINK_TIMEOUT_SIG,           <span class="comment">/* signal for Tunnel&#39;s blink timeout event */</span>
         SCREEN_TIMEOUT_SIG,         <span class="comment">/* signal for Tunnel&#39;s screen timeout event */</span>
         TAKE_OFF_SIG,    <span class="comment">/* from Tunnel to Ship to grant permission to take off */</span>
         HIT_WALL_SIG,            <span class="comment">/* from Tunnel to Ship when Ship hits the wall */</span>
         HIT_MINE_SIG,     <span class="comment">/* from Mine to Ship or Missile when it hits the mine */</span>
         SHIP_IMG_SIG,     <span class="comment">/* from Ship to the Tunnel to draw and check for hits */</span>
         MISSILE_IMG_SIG,  <span class="comment">/* from Missile the Tunnel to draw and check for hits */</span>
         MINE_IMG_SIG,            <span class="comment">/* sent by Mine to the Tunnel to draw the mine */</span>
         MISSILE_FIRE_SIG,                <span class="comment">/* sent by Ship to the Missile to fire */</span>
         DESTROYED_MINE_SIG, <span class="comment">/* from Missile to Ship when Missile destroyed Mine */</span>
         EXPLOSION_SIG,     <span class="comment">/* from any exploding object to render the explosion */</span>
         MINE_PLANT_SIG,                  <span class="comment">/* from Tunnel to the Mine to plant it */</span>
         MINE_DISABLED_SIG,      <span class="comment">/* from Mine to Tunnel when it becomes disabled */</span>
         MINE_RECYCLE_SIG,         <span class="comment">/* sent by Tunnel to Mine to recycle the mine */</span>
         SCORE_SIG,   <span class="comment">/* from Ship to Tunnel to adjust game level based on score */</span>
         <span class="comment">/* insert other signals here ... */</span>
 (4)     MAX_SIG                           <span class="comment">/* the last signal (keep always last) */</span>
     };

 (5) <span class="keyword">typedef</span> <span class="keyword">struct</span> ObjectPosEvtTag {
 (6)     <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> super;                                <span class="comment">/* extend the QEvent class */</span>
 (7)     uint8_t x;                              <span class="comment">/* the x-position of the object */</span>
 (8)     uint8_t y;                              <span class="comment">/* new y-position of the object */</span>
     } ObjectPosEvt;

     <span class="keyword">typedef</span> <span class="keyword">struct </span>ObjectImageEvtTag {
         <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> super;                                <span class="comment">/* extend the QEvent class */</span>
         uint8_t x;                              <span class="comment">/* the x-position of the object */</span>
         int8_t  y;                              <span class="comment">/* the y-position of the object */</span>
         uint8_t bmp;                   <span class="comment">/* the bitmap ID representing the object */</span>
     } ObjectImageEvt;

     <span class="keyword">typedef</span> <span class="keyword">struct </span>MineEvtTag {
         <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> super;                                <span class="comment">/* extend the QEvent class */</span>
         uint8_t id;                                       <span class="comment">/* the ID of the Mine */</span>
     } MineEvt;

     <span class="keyword">typedef</span> <span class="keyword">struct </span>ScoreEvtTag {
         <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> super;                                <span class="comment">/* extend the QEvent class */</span>
         uint16_t score;                                    <span class="comment">/* the current score */</span>
     } ScoreEvt;

     <span class="comment">/* opaque pointers to active objects in the application */</span>
 (9) <span class="keyword">extern</span> <a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> * <span class="keyword">const</span> AO_Tunnel;
(10) <span class="keyword">extern</span> <a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> * <span class="keyword">const</span> AO_Ship;
(11) <span class="keyword">extern</span> <a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> * <span class="keyword">const</span> AO_Missile;

     <span class="comment">/* active objects&#39; &quot;constructors&quot; */</span>
(12) <span class="keywordtype">void</span> Tunnel_ctor(<span class="keywordtype">void</span>);
(13) <span class="keywordtype">void</span> Ship_ctor(<span class="keywordtype">void</span>);
(14) <span class="keywordtype">void</span> Missile_ctor(<span class="keywordtype">void</span>);
</pre></div><ul>
<li>(1) In QP, signals of events are simply enumerated constants. Placing all signals in a single enumeration is particularly convenient to avoid inadvertent overlap in the numerical values of different signals.</li>
</ul>
<ul>
<li>(2) The application-level signals do not start from zero but rather are offset by the constant <a class="el" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074a6b922ebd3f2429b5b5e7b411675fda06">Q_USER_SIG</a>. This is because QP reserves the lowest few signals for the internal use and provides the constant <a class="el" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074a6b922ebd3f2429b5b5e7b411675fda06">Q_USER_SIG</a> as an offset from which user-level signals can start. Please also note that by convention, I attach the suffix <code>_SIG</code> to all signals so that I can easily distinguish signals from other constants. I drop the suffix <code>_SIG</code> in the state diagrams to reduce the clutter.</li>
</ul>
<ul>
<li>(3) The constant <code>MAX_PUB_SIG</code> delimits the published signals from the rest. The publish-subscribe event delivery mechanism consumes some RAM, which is proportional to the number of published signals. I save some RAM by providing the lower limit of published signals to QP (<code>MAX_PUB_SIG</code>) rather than maximum of all signals used in the application. (See also <a class="el" href="main_function.html#L3s1">Listing 3-1</a>(9)).</li>
</ul>
<ul>
<li>(4) The last enumeration <code>MAX_SIG</code> indicates the maximum of all signals used in the application.</li>
</ul>
<ul>
<li>(5) The event structure <code>ObjectPosEvt</code> defines a "class" of events that convey the object's position on the display in the event parameters.</li>
</ul>
<ul>
<li>(6) The structure <code>ObjectPosEvt</code> derives from the base structure <a class="el" href="struct_q_event.html" title="Event structure.">QEvent</a>, as explained in the sidebar <a class="el" href="derivation.html">Encapsulation and Single Inheritance in C</a>.</li>
</ul>
<ul>
<li>(7-8) The structure <code>ObjectPosEvt</code> adds parameters <code>x</code> and <code>y</code>, which are coordinates of the object on the display.</li>
</ul>
<ul>
<li>(9-11) These global pointers represent active objects in the application and are used for posting events directly to active objects. Because the pointers can be initialized at compile time, I like to declare them const, sot that they can be placed in ROM. The active object pointers are "opaque", because they cannot access the whole active object, but only the part inherited from the <a class="el" href="struct_q_active.html" title="Active Object structure.">QActive</a> structure. I'll have more to say about this in the next section.</li>
</ul>
<ul>
<li>(12-14) These functions perform an early initialization of the active objects in the system. They play the role of static "constructors", which in C you need to call explicitly, typically at the beginning of main() (see also <a class="el" href="main_function.html#L3s1">Listing 3-1</a>(10-12)).</li>
</ul>
<h2><a class="anchor" id="generating"></a>
6.2 Generating, Posting, and Publishing Events</h2>
<p>The QF framework supports two types of asynchronous event exchange:</p>
<ol type="1">
<li>The simple mechanism of direct event posting supported through the functions <a class="el" href="qf_8h.html#a5330bd5a4837326763be29d1047d6dd3" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO()</a> and <a class="el" href="qf_8h.html#a27984f6494cd1698adce6f8b957ad6c3" title="Posts an event directly to the event queue of the active object me using the Last-In-First-Out (LIFO)...">QActive_postLIFO()</a>, where the producer of an event directly posts the event to the event queue of the consumer active object.</li>
<li>A more sophisticated publish-subscribe event delivery mechanism supported through the functions <a class="el" href="qf_8h.html#a1bc0bd9f159dfa5b7a19fdb70877e574" title="Publish event to the framework.">QF_publish()</a> and <a class="el" href="qf_8h.html#a2cb9015d643ddbf487112dfefb02eef3" title="Subscribes for delivery of signal sig to the active object me.">QActive_subscribe()</a>, where the producers of the events "publish" them to the framework, and the framework then delivers the events to all active objects that had "subscribed" to these events.</li>
</ol>
<p>In QF, any part of the system can produce events, not necessarily only the active objects. For example, interrupt service routines (ISRs) or device drivers can also produce events. On the other hand, only active objects can consume events, because only active objects have event queues.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>QF also provides "raw" thread-safe event queues (struct <a class="el" href="struct_q_e_queue.html" title="Native QF Event Queue.">QEQueue</a>), which can consume events as well. These "raw" thread-safe queues cannot block and are intended to deliver events to ISRs or device drivers. Please refer to Chapter 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a> for more details.</dd></dl>
<p>The most important characteristic of event management in QF is that the framework passes around only pointers to events, not the events themselves. QF never copies the events by value ("zero-copy" policy); even in case of publishing events that often involves multicasting the same event to multiple subscribers. The actual event instances are either constant events statically allocated at compile time, or dynamic events allocated at runtime from one of the event pools that the framework manages. <a class="el" href="events.html#L6s2">Listing 6-2</a> provides examples of publishing static events and posting dynamic events from the interrupt service routines (ISRs) of the "Fly 'n' Shoot" version for the ARM-Cortex board (file <code>&lt;qpc&gt;\examples\arm-cortex\vanilla\iar\game-ev-lm3s811\bsp.c</code>). In the upcoming Section <a class="el" href="coding_hsm.html">7. Coding Hierarchical State Machines</a> you will see other examples of event posting from active objects in the state machine code.</p>
<p><a class="anchor" id="L6s2"></a> <b>Listing 6-2 Generating, posting , and publishing events from the ISRs in bsp.c for the ARM-Cortex board.</b> </p>
<div class="fragment"><pre class="fragment"> (1) <span class="keywordtype">void</span> ISR_SysTick(<span class="keywordtype">void</span>) {
 (2)     <span class="keyword">static</span> <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> tickEvt = { TIME_TICK_SIG, 0 };
 (3)     <a class="code" href="qf_8h.html#a1bc0bd9f159dfa5b7a19fdb70877e574" title="Publish event to the framework.">QF_publish</a>(&amp;tickEvt);      <span class="comment">/* publish the tick event to all subscribers */</span>
 (4)     <a class="code" href="qf_8h.html#afd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick</a>();                             <span class="comment">/* process all armed time events */</span>
     }
     <span class="comment">/*..........................................................................*/</span>
 (5) <span class="keywordtype">void</span> ISR_ADC(<span class="keywordtype">void</span>) {
         <span class="keyword">static</span> uint32_t adcLPS = 0;            <span class="comment">/* Low-Pass-Filtered ADC reading */</span>
         <span class="keyword">static</span> uint32_t wheel = 0;                   <span class="comment">/* the last wheel position */</span>
         <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> tmp;

         ADCIntClear(ADC_BASE, 3);                    <span class="comment">/* clear the ADC interrupt */</span>
 (6)     ADCSequenceDataGet(ADC_BASE, 3, &amp;tmp);    <span class="comment">/* read the data from the ADC */</span>

         <span class="comment">/* 1st order low-pass filter: time constant ~= 2^n samples</span>
<span class="comment"> TF = (1/2^n)/(z-((2^n - 1)/2^n)),</span>
<span class="comment"> e.g., n=3, y(k+1) = y(k) - y(k)/8 + x(k)/8 =&gt; y += (x - y)/8</span>
<span class="comment">          */</span>
 (7)     adcLPS += (((<span class="keywordtype">int</span>)tmp - (int)adcLPS + 4) &gt;&gt; 3);       <span class="comment">/* Low-Pass-Filter */</span>

         <span class="comment">/* compute the next position of the wheel */</span>
 (8)     tmp = (((1 &lt;&lt; 10) - adcLPS)*(BSP_SCREEN_HEIGHT - 2)) &gt;&gt; 10;

         <span class="keywordflow">if</span> (tmp != wheel) {                   <span class="comment">/* did the wheel position change? */</span>
 (9)         ObjectPosEvt *ope = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(ObjectPosEvt, PLAYER_SHIP_MOVE_SIG);
(10)         ope-&gt;x = (uint8_t)GAME_SHIP_X;               <span class="comment">/* x-position is fixed */</span>
(11)         ope-&gt;y = (uint8_t)tmp;
(12)         <a class="code" href="qf_8h.html#a5330bd5a4837326763be29d1047d6dd3" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO</a>(AO_ship, (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)ope);    <span class="comment">/* post to the Ship AO */</span>
             wheel = tmp;                 <span class="comment">/* save the last position of the wheel */</span>
         }
         . . .
     }
</pre></div><ul>
<li>(1) In the case of the ARM-Cortex board, the function ISR_SysTick() services the system clock tick ISR generated by the ARM-Cortex system tick timer.</li>
</ul>
<ul>
<li>(2) The <code>TIME_TICK</code> event never changes, so it can be statically allocated just once. This event is declared as const, which means that it can be placed in ROM. The initializer list for this event consists of the signal <code>TIME_TICK_SIG</code> followed by zero. This zero informs the QF framework that this event is static and should never be recycled to an event pool.</li>
</ul>
<ul>
<li>(3) The ISR calls the framework function <a class="el" href="qf_8h.html#a1bc0bd9f159dfa5b7a19fdb70877e574" title="Publish event to the framework.">QF_publish()</a>, which takes the pointer to the tickEvt event to deliver to all subscribers.</li>
</ul>
<ul>
<li>(4) The ISR calls the function <a class="el" href="qf_8h.html#afd1f18b068ca10c17eaa3431e77dd290" title="Processes all armed time events at every clock tick.">QF_tick()</a>, in which it the framework manages the armed time events.</li>
</ul>
<ul>
<li>(5) The function <code>ISR_ADC()</code> services the ADC conversions, which ultimately deliver the position of the Ship.</li>
</ul>
<ul>
<li>(6) The ISR reads the data from the ADC.</li>
</ul>
<ul>
<li>(7-8) A low-pass filter is applied to the raw ADC reading and the potentiometer wheel position is computed.</li>
</ul>
<ul>
<li>(9) The QF macro <code><a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW(ObjectPosEvt, PLAYER_SHIP_MOVE_SIG)</a></code> dynamically allocates an instance of the ObjectPosEvt event from an event pool managed by QF. The macro also performs the association between the signal <code>PLAYER_SHIP_MOVE_SIG</code> and the allocated event. The <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW()</a> macro returns the pointer to the allocated event.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The <code>PLAYER_SHIP_MOVE(x, y)</code> event is an example of an event with changing parameters. In general, such an event cannot be allocated statically (like the <code>TIME_TICK</code> event at label (2)) because it can change asynchronously next time the ISR executes. Some active objects in the system might still be referring to the event via a pointer, so the event should not be changing. Dynamic event allocation of QF solves all such concurrency issues, because every time a new event is allocated. QF then recycles the dynamic events, after it determines that all active objects are done with accessing the events.</dd></dl>
<ul>
<li>(10-11) The <code>x</code> and <code>y</code> parameters of the event are assigned.</li>
</ul>
<ul>
<li>(12) The dynamic event is posted directly to the Ship active object.</li>
</ul>
<p>Prev: <a class="el" href="active_objects.html">5. Elaborating State Machines of Active Objects</a> <br/>
 Next: <a class="el" href="coding_hsm.html">7. Coding Hierarchical State Machines</a></p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
</div>
<p> Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.<br/>
 <a href="http://www.state-machine.com">http://www.state-machine.com</a> </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 26 2011 09:40:34 for QP/C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
