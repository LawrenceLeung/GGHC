<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C: 7. Coding Hierarchical State Machines</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">QP/C Reference Manual</a>      </li>
      <li class="navelem"><a class="el" href="tutorial_page.html">QP/C Tutorial</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>7. Coding Hierarchical State Machines </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p><em>This QP/C Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br/>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em></p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg"/>
</div>
<p>Prev: <a class="el" href="events.html">6. Defining Event Signals and Event Parameters</a> <br/>
 Next: <a class="el" href="execution.html">8. Using the Built-in Real-Time Kernels and Third-Party RTOSes</a></p>
<p>Contrary to widespread misconceptions, you don't need big design automation tools to translate hierarchical state machines (UML statecharts) into efficient and highly maintainable C or C++. This section explains how to hand-code the Ship state machine from <a class="el" href="active_objects.html#F5s2">Figure 5-2</a> with the help of the QF real-time framework and the QEP hierarchical processor, which is also part of the QP event-driven platform. Once you know how to code this state machine, you know how to code them all.</p>
<p>The source code for the Ship state machine is found in the file <code>ship.c</code> located either in the DOS version or the ARM-Cortex version of the "Fly 'n'
Shoot" game. I break the explanation of this file into <b>three</b> steps.</p>
<h2><a class="anchor" id="step1"></a>
7.1 Step 1: Defining the Ship Structure</h2>
<p>In the first step you define the Ship data structure. Just like in case of events, you use inheritance to derive the Ship structure from the framework structure <a class="el" href="struct_q_active.html" title="Active Object structure.">QActive</a> (see the sidebar <a class="el" href="derivation.html">Encapsulation and Single Inheritance in C</a>). Creating this inheritance relationship ties the Ship structure to the QF framework. The main responsibility of the <a class="el" href="struct_q_active.html" title="Active Object structure.">QActive</a> base structure is to store the information about the current active state of the state machine, as well as the event queue and priority level of the Ship active object. In fact, <a class="el" href="struct_q_active.html" title="Active Object structure.">QActive</a> itself derives from a simpler QEP structure QHsm that represents just the current active state of a hierarchical state machine. On top of that information, almost every state machine must also store other "extended-state" information. For example, the Ship object is responsible for maintaining the Ship position as well as the score accumulated in the game. You supply this additional information by means of data members enlisted after the base structure member super, as shown in <a class="el" href="coding_hsm.html#L7s1">Listing 7-1</a>.</p>
<p><a class="anchor" id="L7s1"></a> <b>Listing 7-1 Deriving the Ship structure in file ship.c.</b> </p>
<div class="fragment"><pre class="fragment"> (1) #include <span class="stringliteral">&quot;qp_port.h&quot;</span>                                         <span class="comment">/* the QP port */</span>
 (2) #include <span class="stringliteral">&quot;bsp.h&quot;</span>                                   <span class="comment">/* Board Support Package */</span>
 (3) #include <span class="stringliteral">&quot;game.h&quot;</span>                                       <span class="comment">/* this application */</span>

     <span class="comment">/* local objects -----------------------------------------------------------*/</span>
 (4) typedef struct ShipTag {
 (5)     <a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> super;                        <span class="comment">/* derive from the QActive struct */</span>
 (6)     uint8_t x;          <span class="comment">/* x-coordinate of the Ship position on the display */</span>
 (7)     uint8_t y;          <span class="comment">/* y-coordinate of the Ship position on the display */</span>
 (8)     uint8_t exp_ctr;       <span class="comment">/* explosion counter, used to animate explosions */</span>
 (9)     uint16_t score;                            <span class="comment">/* running score of the game */</span>
(10) } Ship;                          <span class="comment">/* the typedef-ed name for the Ship struct */</span>

                                                   <span class="comment">/* state handler functions... */</span>
(11) <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship_active   (Ship *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e);
(12) <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship_parked   (Ship *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e);
(13) <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship_flying   (Ship *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e);
(14) <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship_exploding(Ship *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e);

(15) <span class="keyword">static</span> <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship_initial  (Ship *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e);

(16) <span class="keyword">static</span> Ship l_ship;          <span class="comment">/* the sole instance of the Ship active object */</span>

     <span class="comment">/* global objects ----------------------------------------------------------*/</span>
(17) <a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> * <span class="keyword">const</span> AO_ship = (<a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *)&amp;l_ship;  <span class="comment">/* opaque pointer to Ship AO */</span>
</pre></div><ul>
<li>(1) Every application-level C-file that uses the QP platform must include the <code>qp_port.h</code> header file.</li>
</ul>
<ul>
<li>(2) The <code>bsp.h</code> header file contains the interface to the Board Support Package.</li>
</ul>
<ul>
<li>(3) The <code>game.h</code> header file contains the declarations of events and other facilities shared among the components of the application </li>
<li>(see <a class="el" href="events.html#L6s1">Listing 6-1</a>).</li>
</ul>
<ul>
<li>(4) This structure defines the Ship active object.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>I like to keep active objects, and indeed all state machine objects (such as Mines), strictly encapsulated. Therefore, I don't put the state machine structure definitions in header files but rather define them right in the implementation file, such as ship.c. That way, I can be sure that the internal data members of the Ship structure are not known to any other parts of the application.</dd></dl>
<ul>
<li>(5) The Ship active object structure derives from the framework structure <a class="el" href="struct_q_active.html" title="Active Object structure.">QActive</a>, as described in the sidebar <a class="el" href="derivation.html">Encapsulation and Single Inheritance in C</a>.</li>
</ul>
<ul>
<li>(6-7) The x and y data members represent the position of the Ship on the display.</li>
</ul>
<ul>
<li>(8) The exp_ctr member is used for pacing the explosion animation (see also the "exploding" state in the Ship state diagram in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>).</li>
</ul>
<ul>
<li>(9) The score member stores the accumulated score in the game.</li>
</ul>
<ul>
<li>(10) I use the typedef to define the shorter name Ship equivalent to struct ShipTag.</li>
</ul>
<ul>
<li>(11-14) These four functions are called state-handler functions because they correspond one-to-one to the states of the Ship state machine shown in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>. For example, the <code>Ship_active()</code> function represents the "active" state. The QEP event processor calls the state handler functions to realize the UML semantics of state machine execution. <code>&lt;qpc&gt;\include\<a class="el" href="qep_8h.html" title="Public QEP/C interface.">qep.h</a></code>. All state handler functions have the same signature. A state handler function takes the state machine pointer and the event pointer as arguments, and returns the status of the operation back to the QEP event processor, for example whether the event was handled or not. The return type QState is typedef-ed to <code>uint8_t</code> in the header file <code>&lt;qpc&gt;\include\<a class="el" href="qep_8h.html" title="Public QEP/C interface.">qep.h</a></code>.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>I use a simple naming convention to strengthen the association between the structures and the functions designed to operate on these structures. First, I name the functions by combining the typedef'ed structure name with the name of the operation (e.g., <code>Ship_active</code>). Second, I always place the pointer to the structure as the first argument of the associated function and I always name this argument <code>me</code> (e.g., <code>Ship_active(Ship *me, ...)</code>).</dd></dl>
<ul>
<li>(16) In addition to state handler functions, every state machine must declare the initial pseudostate, which QEP invokes to execute the top-most initial transition (see <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(1)). The initial pseudostate handler has signature identical to the regular state handler function.</li>
</ul>
<ul>
<li>(17) In this line I statically allocate the storage for the Ship active object. Please note that the object l_ship is defined static, so that it is accessible only locally at the file scope of the ship.c file.</li>
</ul>
<ul>
<li>(18) In this line I define and initialize the global pointer AO_Ship to the Ship active object (see also <a class="el" href="events.html#L6s1">Listing 6-1</a>(10)). This pointer is "opaque", because it treats the Ship object as the generic <a class="el" href="struct_q_active.html" title="Active Object structure.">QActive</a> base structure, rather than the specific Ship structure. The power of an "opaque" pointer is that it allows me to completely hide the definition of the Ship structure and make it inaccessible to the rest of the application. Still, the other application components can access the Ship object to post events directly to it via the <a class="el" href="qa__fifo_8c.html#a5330bd5a4837326763be29d1047d6dd3" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO(QActive *me, QEvent const *e)</a> function.</li>
</ul>
<h2><a class="anchor" id="step2"></a>
7.2 Step 2: Initializing the State Machine</h2>
<p>The state machine initialization is divided into the following two steps for increased flexibility and better control of the initialization timeline:</p>
<ol type="1">
<li>The state machine "constructor"; and</li>
<li>The top-most initial transition.</li>
</ol>
<p>The state machine "constructor", such as <code>Ship_ctor()</code>, intentionally does not execute the top-most initial transition defined in the initial pseudostate because at that time some vital objects can be missing and critical hardware might not be properly initialized yet3. Instead, the state machine "constructor" merely puts the state machine in the initial pseudostate. Later, the user code must trigger the top-most initial transition explicitly, which happens actually inside the function <a class="el" href="qf_8h.html#a0123f02b4c1bcf7df2cc0b11dfce8b09" title="Starts execution of an active object and registers the object with the framework.">QActive_start()</a> (see <a class="el" href="main_function.html#L3s1">Listing 3-11</a>(18-20)). <a class="el" href="coding_hsm.html#L7s2">Listing 7-2</a> shows the instantiation (the "constructor" function) and initialization (the initial pseudostate) of the Ship active object.</p>
<p><a class="anchor" id="L7s2"></a> <b>Listing 7-2 Instantiation and Initialization of the Ship active object in ship.c.</b> </p>
<div class="fragment"><pre class="fragment"> (1) <span class="keywordtype">void</span> Ship_ctor(<span class="keywordtype">void</span>) {                                     <span class="comment">/* instantiation */</span>
 (2)     Ship *me = &amp;l_ship;
 (3)     <a class="code" href="qf_8h.html#a7ddf2dd243b2bc13589a9c7d22f0e253" title="protected &amp;quot;constructor&amp;quot; of an active object. Performs the first step of active object initi...">QActive_ctor</a>(&amp;me-&gt;super, (<a class="code" href="qep_8h.html#ac2c368a1ec5e2037c5f4d54f24b3da95" title="pointer to state-handler function">QStateHandler</a>)&amp;Ship_initial);
 (4)     me-&gt;x = GAME_SHIP_X;
 (5)     me-&gt;y = GAME_SHIP_Y;
     }
     <span class="comment">/*..........................................................................*/</span>
 (6) <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship_initial(Ship *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e) {          <span class="comment">/* initialization */</span>
 (7)     <a class="code" href="qf_8h.html#a2cb9015d643ddbf487112dfefb02eef3" title="Subscribes for delivery of signal sig to the active object me.">QActive_subscribe</a>((<a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *)me, TIME_TICK_SIG);
 (8)     <a class="code" href="qf_8h.html#a2cb9015d643ddbf487112dfefb02eef3" title="Subscribes for delivery of signal sig to the active object me.">QActive_subscribe</a>((<a class="code" href="struct_q_active.html" title="Active Object structure.">QActive</a> *)me, PLAYER_TRIGGER_SIG);

 (9)     <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN</a>(&amp;Ship_active);             <span class="comment">/* top-most initial transition */</span>
     }
</pre></div><ul>
<li>(1) The global function Ship_ctor() is prototyped in game.h and called at the beginning of main().</li>
</ul>
<ul>
<li>(2) The "me" pointer points to the statically allocated Ship object (see <a class="el" href="coding_hsm.html#L7s1">Listing 7-1</a>(16)).</li>
</ul>
<ul>
<li>(3) Every derived structure is responsible for initializing the part inherited from the base structure. The "constructor" <a class="el" href="qf_8h.html#a7ddf2dd243b2bc13589a9c7d22f0e253" title="protected &quot;constructor&quot; of an active object. Performs the first step of active object initi...">QActive_ctor()</a> puts the state machine in the initial pseudostate &amp;Ship_initial. (see <a class="el" href="events.html#L6s1">Listing 6-1</a>(15)).</li>
</ul>
<ul>
<li>(4-5) The Ship position is initialized.</li>
</ul>
<ul>
<li>(6) The Ship_initial() function defines the top-most initial transition in the Ship state machine (see <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(1)).</li>
</ul>
<ul>
<li>(7-8) The Ship active object subscribes to signals <code>TIME_TICK_SIG</code> and <code>PLAYER_TRIGGER_SIG</code>, as specified in the state diagram in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(1).</li>
</ul>
<ul>
<li>(9) The initial state "active" is specified by invoking the QP macro <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a>.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The macro <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a> must always follow the return statement.</dd></dl>
<h2><a class="anchor" id="step3"></a>
7.3 Step 3: Defining State Handler Functions</h2>
<p>In the last step, you actually code the Ship state machine by implementing one state at a time as a state handler function. To determine what elements belong the any given state handler function, you follow around the state's boundary in the diagram (<a class="el" href="active_objects.html#F5s2">Figure 5-2</a>). You need to implement all transitions originating at the boundary, any entry and exit actions defined in the state, as well as all internal transitions enlisted directly in the state. Additionally, if there is an initial transition embedded directly in the state, you need to implement it as well.</p>
<p>Take for example the state "flying" shown in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>. This state has an entry action and two transitions originating at its boundary: <code>HIT_WALL</code> and <code>HIT_MINE(type)</code>, as well as three internal transitions <code>TIME_TICK</code>, <code>PLAYER_TRIGGER</code>, and <code>DESTROYED_MINE(score)</code>. The "flying" state nests inside the "active" superstate. <a class="el" href="coding_hsm.html#L7s3">Listing 7-3</a> shows two state handler functions of the Ship state machine from <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>. The state handler functions correspond to the states "active" and "flying", respectively. The explanation section immediately following the listing highlights the important implementation techniques.</p>
<p><a class="anchor" id="L7s3"></a> <b>Listing 7-3 State handler functions for states "active" and "flying" in ship.c.</b> </p>
<div class="fragment"><pre class="fragment"> (1) <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship_active(Ship *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e) {
 (2)     <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="struct_q_event.html#af3f51670fdc402116309573cee25447d">sig</a>) {
 (3)         <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074a28691a94425fb031be4044e817e21a60">Q_INIT_SIG</a>: {                     <span class="comment">/* nested initial transition */</span>
 (4)             <span class="comment">/* any actions associated with the initial transition */</span>
 (5)             <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN</a>(&amp;Ship_parked);
             }
 (6)         <span class="keywordflow">case</span> PLAYER_SHIP_MOVE_SIG: {
 (7)             me-&gt;x = ((ObjectPosEvt <span class="keyword">const</span> *)e)-&gt;x;
 (8)             me-&gt;y = ((ObjectPosEvt <span class="keyword">const</span> *)e)-&gt;y;
 (9)             <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
             }
         }
(10)     <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;<a class="code" href="qep_8h.html#af10689a40419f959e0c12343ed281506" title="the top-state.">QHsm_top</a>);                     <span class="comment">/* return the superstate */</span>
     }
     <span class="comment">/*..........................................................................*/</span>
     <a class="code" href="qep_8h.html#a76c35d858e243d1bd3106738573902d0" title="Type returned from a state-handler function.">QState</a> Ship_flying(Ship *me, <a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> <span class="keyword">const</span> *e) {
         <span class="keywordflow">switch</span> (e-&gt;<a class="code" href="struct_q_event.html#af3f51670fdc402116309573cee25447d">sig</a>) {
(11)         <span class="keywordflow">case</span> <a class="code" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a>: {
(12)             ScoreEvt *sev;

                 me-&gt;score = 0;                               <span class="comment">/* reset the score */</span>
(13)             sev = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(ScoreEvt, SCORE_SIG);
(14)             sev-&gt;score = me-&gt;score;
(15)             <a class="code" href="qf_8h.html#a5330bd5a4837326763be29d1047d6dd3" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO</a>(AO_Tunnel, (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)sev);
(16)             <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
             }
             <span class="keywordflow">case</span> TIME_TICK_SIG: {
                 <span class="comment">/* tell the Tunnel to draw the Ship and test for hits */</span>
                 ObjectImageEvt *oie = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(ObjectImageEvt, SHIP_IMG_SIG);
                 oie-&gt;x   = me-&gt;x;
                 oie-&gt;y   = me-&gt;y;
                 oie-&gt;bmp = SHIP_BMP;
                 <a class="code" href="qf_8h.html#a5330bd5a4837326763be29d1047d6dd3" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO</a>(AO_Tunnel, (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)oie);

                 ++me-&gt;score;  <span class="comment">/* increment the score for surviving another tick */</span>

                 <span class="keywordflow">if</span> ((me-&gt;score % 10) == 0) {           <span class="comment">/* is the score &quot;round&quot;? */</span>
                     ScoreEvt *sev = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(ScoreEvt, SCORE_SIG);
                     sev-&gt;score = me-&gt;score;
                     <a class="code" href="qf_8h.html#a5330bd5a4837326763be29d1047d6dd3" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO</a>(AO_Tunnel, (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)sev);
                 }
                 <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
             }
             <span class="keywordflow">case</span> PLAYER_TRIGGER_SIG: {                   <span class="comment">/* trigger the Missile */</span>
                 ObjectPosEvt *ope = <a class="code" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW</a>(ObjectPosEvt, MISSILE_FIRE_SIG);
                 ope-&gt;x = me-&gt;x;
                 ope-&gt;y = me-&gt;y + SHIP_HEIGHT - 1;
                 <a class="code" href="qf_8h.html#a5330bd5a4837326763be29d1047d6dd3" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO</a>(AO_Missile, (<a class="code" href="struct_q_event.html" title="Event structure.">QEvent</a> *)ope);
                 <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
             }
             <span class="keywordflow">case</span> DESTROYED_MINE_SIG: {
                 me-&gt;score += ((ScoreEvt <span class="keyword">const</span> *)e)-&gt;score;
                 <span class="comment">/* the score will be sent to the Tunnel by the next TIME_TICK */</span>
                 <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a54b2da5e70ef983cfa7ca74deac237a3" title="Value returned by a state-handler function when it handles the event.">Q_HANDLED</a>();
             }
(17)         <span class="keywordflow">case</span> HIT_WALL_SIG:
(18)         <span class="keywordflow">case</span> HIT_MINE_SIG: {
(19)             <span class="comment">/* any actions associated with the transition */</span>
(20)             <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN</a>(&amp;Ship_exploding);
             }
         }
(21)     <span class="keywordflow">return</span> <a class="code" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER</a>(&amp;Ship_active);                  <span class="comment">/* return the superstate */</span>
     }
</pre></div><ul>
<li>(1) Each state handler must have the same signature, that is, it must take two parameters: the state machine pointer "me" and the pointer to <a class="el" href="struct_q_event.html" title="Event structure.">QEvent</a>. The keyword const before the '*' in the event pointer declaration means that the event pointed to by that pointer cannot be changed inside the state handler function (i.e., the event is read-only). A state handler function must return QState, which conveys the status of the event handling to the QEP event processor.</li>
</ul>
<ul>
<li>(2) Typically, every state handler is structured as a switch statement that discriminates based on the signal of the event signal e-&gt;sig.</li>
</ul>
<ul>
<li>(3) This line of code pertains to the nested initial transition <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(2). QEP provides a reserved signal <a class="el" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074a28691a94425fb031be4044e817e21a60">Q_INIT_SIG</a> that the framework passes to the state handler function when it wants to execute the initial transition.</li>
</ul>
<ul>
<li>(4) You can enlist any actions associated with this initial transition (none in this particular case).</li>
</ul>
<ul>
<li>(5) You designate the target substate with the <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a> macro. This macro must always follow the return statement, through which the state handler function informs the QEP event processor that the transition has been taken.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The initial transition must necessarily target a direct or transitive substate of a given state. An initial transition cannot target a peer state or go up in state hierarchy to higher-level states, which in the UML would represent a "malformed" state machine.</dd></dl>
<ul>
<li>(6) This line of code pertains to the internal transition <code>PLAYER_SHIP_MOVE_SIG(x, y)</code> in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(3).</li>
</ul>
<ul>
<li>(7-8) You access the data members of the Ship state machine via the "me" argument of the state handler function. You access the event parameters via the "e" argument. You need to cast the event pointer from the generic <a class="el" href="struct_q_event.html" title="Event structure.">QEvent</a> base class to the specific event structure expected for the PLAYER_SHIP_MOVE_SIG, which is ObjectPosEvt in this case.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The association between the event signal and event structure (event parameters) is established at the time the event is generated. All recipients of that event must know about this association to perform the cast to the correct event structure.</dd></dl>
<ul>
<li>(9) You terminate the case statement with "&lt;TT&gt;return Q_HANDLED()&lt;/TT&gt;", which informs the QEP event processor that the event has been handled (but no transition has been taken).</li>
</ul>
<ul>
<li>(10) The final return from a state handler function designates the superstate of that state by means of the QEP macro <a class="el" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER()</a>. The final return statement from a state handler function represents the single point of maintenance for changing the nesting level of a given state. The state "active" in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a> has no explicit superstate, which means that it is implicitly nested in the "top" state. The "top" state is a UML concept that denotes the ultimate root of the state hierarchy in a hierarchical state machine. QEP provides the "top" state as a state handler function <a class="el" href="qep_8h.html#af10689a40419f959e0c12343ed281506" title="the top-state.">QHsm_top()</a>, and therefore the Ship_active() state handler returns the pointer &amp;QHsm_top.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>In C and C++, a pointer-to-function <a class="el" href="qep_8h.html#af10689a40419f959e0c12343ed281506" title="the top-state.">QHsm_top()</a> can be written either as QHsm_top, or &amp;QHsm_top. Even though the notation QHsm_top is more succinct, I prefer adding the ampersand explicitly, to leave absolutely no doubt that I mean a pointer-to-function &amp;QHsm_top.</dd></dl>
<ul>
<li>(11) This line of code pertains to the entry action into state "flying" (<a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(5)). QEP provides a reserved signal <a class="el" href="qep_8h.html#ae35e58b2153d1c63307c068315be9074ac286909dd59290d1076b51d4cfdfaefe">Q_ENTRY_SIG</a> that the framework passes to the state handler function when it wants to execute the entry actions.</li>
</ul>
<ul>
<li>(12) The entry action to "flying" posts the SCORE event to the Tunnel active object (<a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(5)). This line defines a temporary pointer to the event structure ScoreEvt.</li>
</ul>
<ul>
<li>(13) The QF macro <code><a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW(ScoreEvt, SCORE_SIG)</a></code> dynamically allocates an instance of the ScoreEvt from an event pool managed by QF. The macro also performs the association between the signal SCORE_SIG and the allocated event. The <a class="el" href="qf_8h.html#abd823f3a9e8b3206a3460a108d5fa3e3" title="Allocate a dynamic event.">Q_NEW()</a> macro returns the pointer to the allocated event.</li>
</ul>
<ul>
<li>(14) The score parameter of the ScoreEvt is set from the state machine member me-&gt;score.</li>
</ul>
<ul>
<li>(15) The SCORE(me-&gt;score) event is posted directly to the Tunnel active object by means of the QP function <a class="el" href="qf_8h.html#a5330bd5a4837326763be29d1047d6dd3" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO()</a>. The arguments of this function are the recipient active object (AO_Tunnel in this case) and the pointer to the event (the temporary pointer sev in this case).</li>
</ul>
<ul>
<li>(16) You terminate the case statement with "&lt;TT&gt;return Q_HANDLED()&lt;/TT&gt;", which informs QEP that the entry actions have been handled.</li>
</ul>
<ul>
<li>(17-18) These two lines of code pertain to the state transitions from "flying" to "exploding" (<a class="el" href="active_objects.html#F5s2">Figure 5-2</a>(9, 10)).</li>
</ul>
<ul>
<li>(19) You can enlist any actions associated with the transition (none in this particular case).</li>
</ul>
<ul>
<li>(20) You designate the target of the transition with the <a class="el" href="qep_8h.html#a8f06cd90ba5060780fc61a4810e3eb50" title="Designates a target for an initial or regular transition. Q_TRAN() can be used both in the FSMs and H...">Q_TRAN()</a> macro.</li>
</ul>
<ul>
<li>(21) The final return from a state handler function designates the superstate of that state. The state "flying" in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a> nests in the state "active", so the state handler Ship_flying() returns the pointer &amp;Ship_active wrapped with the macro <a class="el" href="qep_8h.html#ad8abd2f7098c41ec464343d9d8f1eadc" title="Designates the superstate of a given state in an HSM.">Q_SUPER()</a>.</li>
</ul>
<p>When implementing state handler functions you need to keep in mind that the QEP event processor is in charge here rather than your code. QEP will invoke a state handler function for various reasons: for hierarchical event processing, for execution of entry and exit actions, for triggering initial transitions, or even just to elicit the superstate of a given state handler. Therefore, you should not assume that a state handler would be invoked only for processing signals enlisted in the case statements. You should avoid any code outside the switch statement, especially code that would have side effects.</p>
<p>Prev: <a class="el" href="events.html">6. Defining Event Signals and Event Parameters</a> <br/>
 Next: <a class="el" href="execution.html">8. Using the Built-in Real-Time Kernels and Third-Party RTOSes</a></p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
</div>
<p> Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.<br/>
 <a href="http://www.state-machine.com">http://www.state-machine.com</a> </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 26 2011 09:40:34 for QP/C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
