<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QP/C: 5. Elaborating State Machines of Active Objects</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">QP/C</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">QP/C Reference Manual</a>      </li>
      <li class="navelem"><a class="el" href="tutorial_page.html">QP/C Tutorial</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>5. Elaborating State Machines of Active Objects </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><p><em>This QP/C Tutorial is adapted from Chapter 1 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a><br/>
 by Miro Samek, the founder and president of Quantum Leaps, LLC.</em></p>
<div align="center">
<img src="qp_tutorial.jpg" alt="qp_tutorial.jpg"/>
</div>
<p>Prev: <a class="el" href="design.html">4. Designing an Event-Driven Application</a> <br/>
 Next: <a class="el" href="events.html">6. Defining Event Signals and Event Parameters</a></p>
<p>I hope that the analysis of the sequence diagram in <a class="el" href="design.html#F4s1">Figure 4-1</a> makes it clear that actions performed by an active object depend as much on the events it receives, as on the internal mode of the object. For example, the Missile active object handles the <code>TIME_TICK</code> event very differently when the Missile is in flight (<a class="el" href="design.html#F4s1">Figure 4-1</a>(12)) compared to the time when it is not (<a class="el" href="design.html#F4s1">Figure 4-1</a>(3)). The best known mechanism of handling such modal behavior is through state machines because a state machine makes the behavior explicitly dependent on both the event and the state of an object. In Chapter 2 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a> I introduce UML state machine concepts more thoroughly. In this section, I give a cursory explanation of the state machines associated with each object in the "Fly 'n' Shoot" game.</p>
<h2><a class="anchor" id="missile"></a>
5.1 The Missile Active Object</h2>
<p>I start with the Missile state machine shown in <a class="el" href="active_objects.html#F5s1">Figure 5-1</a>, because it turns out to be the simplest one. The explanation section immediately following the diagram illuminates the interesting points.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>A UML state diagram like <a class="el" href="active_objects.html#F5s1">Figure 5-1</a> preserves the general form of the traditional state transition diagrams, where states are represented as nodes and transitions as arcs connecting the nodes. In the UML notation the state nodes are represented as rectangles with rounded corners. The name of the state appears in bold type in the name compartment at the top of the state. Optionally, right below the name, a state can have an internal transition compartment separated from the name by a horizontal line. The internal transition compartment can contain entry actions (actions following the reserved symbol "entry"), exit actions (actions following the reserved symbol "exit"), and other internal transitions (e.g., those triggered by <code>TIME_TICK</code> in <a class="el" href="active_objects.html#F5s1">Figure 5-1</a>(3)). State transitions are represented as arrows originating at the boundary of the source state and pointing to the boundary of the target state. At a minimum, a transition must be labeled with the triggering event. Optionally, the trigger can be followed by event parameters, a guard, and a list of actions.</dd></dl>
<p><a class="anchor" id="F5s1"></a> </p>
<div align="center">
<img src="Fig1.05.jpg" alt="Fig1.05.jpg"/>
<p><strong>Figure 5-1 Missile state machine diagram.</strong></p></div>
 <ul>
<li>(1) The state transition originating at the black ball is called the initial transition. Such transition designates the first active state after the state machine object is created. An initial transition can have associated actions, which in the UML notation are enlisted after the forward slash "/". In this particular case, the Missile state machine starts in the "armed" state and the actions executed upon the initialization consist of subscribing to the event <code>TIME_TICK</code>. Subscribing to an event means that the framework will deliver the specified event to the Missile active object every time the event is published to the framework. Chapter 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a> describes the implementation of the publish-subscribe event delivery in QF.</li>
</ul>
<ul>
<li>(2) The arrow labeled with the <code>MISSILE_FIRE(x, y)</code> event denotes a state transition, that is, change of state from "armed" to "flying". The <code>MISSILE_FIRE(x, y)</code> event is generated by the Ship object when the Player triggers the Missile (see the sequence diagram in <a class="el" href="design.html#F4s1">Figure 4-1</a>). In the <code>MISSILE_FIRE</code> event, Ship provides Missile with the initial coordinates in the event parameters <code>(x, y)</code>.</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>The UML intentionally does not specify the notation for actions. In practice, the actions are often written in the programming language used for coding the particular state machine. In all state diagrams in this book, I assume the C programming language. Furthermore, in the C expressions I refer to the data members associated with the state machine object through the <code>me-&gt;</code> prefix and to the event parameters through the <code>e-&gt;</code> prefix. For example, the action <code>me-&gt;x = e-&gt;x;</code> means that the internal data member <code>x</code> of the Missile active object is assigned the value of the event parameter <code>x</code>.</dd></dl>
<ul>
<li>(3) The event name <code>TIME_TICK</code> enlisted in the compartment below the state name denotes an internal transition. Internal transitions are simple reactions to events performed without a change of state. An internal transition, as well as a regular transition, can have a guard condition, enclosed in square brackets. Guard condition is a Boolean expression evaluated at runtime. If the guard evaluates to TRUE, the transition is taken. Otherwise, the transition is not taken and no actions enlisted after the forward slash "/" are executed. In this particular case, the guard condition checks whether the x-coordinate propagated by the Missile speed is still visible on the screen. If so, the actions are executed. These actions include propagation of the Missile position by one step and posting the <code>MISSILE_IMG</code> event with the current Missile position and the <code>MISSILE_BMP</code> bitmap number to the Tunnel active object. Direct event posting to an active object is accomplished by the QF function <a class="el" href="qf_8h.html#a5330bd5a4837326763be29d1047d6dd3" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO()</a>, which I discuss in Chapter 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>.</li>
</ul>
<ul>
<li>(4) The same event <code>TIME_TICK</code> with the <code>[else]</code> guard denotes a regular state transition with the guard condition complementary to the other occurrence of the <code>TIME_TICK</code> event in the same state. In this case, the <code>TIME_TICK</code> transition to "armed" is taken if the Missile object flies out of the screen.</li>
</ul>
<ul>
<li>(5) The event <code>HIT_MINE(score)</code> triggers another transition to the "armed" state. The action associated with this transition posts the <code>DESTROYED_MINE</code> event with the parameter e-&gt;score to the Ship object, to report destroying the mine.</li>
</ul>
<ul>
<li>(6) The event <code>HIT_WALL</code> triggers a transition to the "exploding" state, with the purpose of animating the explosion bitmaps on the display.</li>
</ul>
<ul>
<li>(7) The label "entry" denotes the entry action to be executed unconditionally upon the entry to the "exploding" state. This action consists of clearing explosion counter (<code>me-&gt;exp_ctr</code>) member of the Missile object.</li>
</ul>
<ul>
<li>(8) The <code>TIME_TICK</code> internal transition is guarded by the condition that the explosion does not scroll off the screen, and that the explosion counter is lower than 16. The actions executed include propagation of the explosion position and posting the <code>EXPLOSION_IMG</code> event to the Tunnel active object. Please note that the bitmap of the explosion changes as the explosion counter gets bigger.</li>
</ul>
<ul>
<li>(6) The <code>TIME_TICK</code> regular transition with the complementary guard changes the state back to the "armed" state. This transition is taken after the animation of the explosion completes.</li>
</ul>
<h2><a class="anchor" id="ship"></a>
5.2 The Ship Active Object</h2>
<p>The state machine of the Ship active object is shown in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>. This state machine introduces the profound concept of hierarchical state nesting. The power of state nesting derives from the fact that it is designed to eliminate repetitions that otherwise would have to occur.</p>
<p>One of the main responsibilities of the Ship active object is to maintain the current position of the Ship. On the original LM3S811 board, this position is determined by the potentiometer wheel (see <a class="el" href="lets_play.html#F2s2">Figure 2-2</a>). The <code>PLAYER_SHIP_MOVE(x, y)</code> event is generated whenever the wheel position changes, as shown in the sequence diagram (<a class="el" href="design.html#F4s1">Figure 4-1</a>). The Ship object must always keep track of the wheel position, which means that all states of the Ship state machine must handle the <code>PLAYER_SHIP_MOVE(x, y)</code> event.</p>
<p>In the traditional finite state machine (FSM) formalism, you would need to repeat the Ship position update from the <code>PLAYER_SHIP_MOVE(x, y)</code> event in every state. But such repetitions would bloat the state machine and, more importantly, would represent multiple points of maintenance both in the diagram and the code. Such repetitions go against the DRY principle (Don't Repeat Yourself), which is vital for flexible and maintainable code.</p>
<p>Hierarchical state nesting remedies the problem. Consider the state "active" that surrounds all other states in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>. The high-level "active" state is called the superstate and is abstract in that the state machine cannot be in this state directly, but only in one of the states nested within, which are called the substates of "active". The UML semantics associated with state nesting prescribes that any event is first handled in the context of the currently active substate. If the substate cannot handle the event, the state machine attempts to handle the event in the context of the next-level superstate. Of course, state nesting in UML is not limited to just one level and the simple rule of processing events applies recursively to any level of nesting.</p>
<p>Specifically to the Ship state machine diagram shown in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>, suppose that the event <code>PLAYER_SHIP_MOVE(x, y)</code> arrives when the state machine is in the "parked" state. The "parked" state does not handle the <code>PLAYER_SHIP_MOVE(x, y)</code> event. In the traditional finite state machine this would be the end of story—the <code>PLAYER_SHIP_MOVE(x, y)</code> event would be silently discarded. However, the state machine in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a> has another layer of the "active" superstate. Per the semantics of state nesting, this higher-level superstate handles the PLAYER_SHIP_MOVE(x, y) event, which is exactly what's needed. The same exact argumentation applies for any other substate of the "active" superstate, such as "flying" or "exploding", because none of these substates handle the <code>PLAYER_SHIP_MOVE(x, y)</code> event. Instead, the "active" superstate handles the event in one single place, without repetitions.</p>
<p><a class="anchor" id="F5s2"></a> </p>
<div align="center">
<img src="Fig1.06.jpg" alt="Fig1.06.jpg"/>
<p><strong>Figure 5-2 Ship state machine diagram.</strong></p></div>
 <ul>
<li>(1) Upon the initial transition, the Ship state machine enters the "active" superstate and subscribes to events <code>TIME_TICK</code> and <code>PLAYER_TRIGGER</code>.</li>
</ul>
<ul>
<li>(2) At each level of nesting a superstate can have a private initial transition that designates the active substate after the superstate is entered directly. Here the initial transition of state "active" designates the substate "parked" as the initial active substate.</li>
</ul>
<ul>
<li>(3) The "active" superstate handles the <code>PLAYER_SHIP_MOVE(x, y)</code> event as an internal transition in which it updates the internal data members <code>me-&gt;x</code> and <code>me-&gt;y</code> from the event parameters <code>e-&gt;x</code> and <code>e-&gt;y</code>, respectively.</li>
</ul>
<ul>
<li>(4) The TAKE_OFF event triggers transition to "flying". This event is generated by the Tunnel object when the Player starts the game (see the description of the game in Section <a class="el" href="lets_play.html">2. Let's Play</a>).</li>
</ul>
<ul>
<li>(5) The entry actions to "flying" include clearing the me-&gt;score data member and posting the event <code>SCORE</code> with the event parameter me-&gt;score to the Tunnel active object.</li>
</ul>
<ul>
<li>(6) The <code>TIME_TICK</code> internal transition causes posting the event <code>SHIP_IMG</code> with current Ship position and the <code>SHIP_BMP</code> bitmap number to the Tunnel active object. Additionally, the score is incremented for surviving another time tick. Finally, when the score is "round" (divisible by 10) it is also posted to the Tunnel active object. This decimation of the <code>SCORE</code> event is performed just to reduce the bandwidth of the communication, because the Tunnel active object only needs to give an approximation of the running score tally to the user.</li>
</ul>
<ul>
<li>(7) The <code>PLAYER_TRIIGGER</code> internal transition causes posting the event <code>MISSILE_FIRE</code> with current Ship position to the Missile active object. The parameters <code>(me-&gt;x, me-&gt;y)</code> provide the Missile with the initial position from the Ship.</li>
</ul>
<ul>
<li>(8) The <code>DESTROYED_MINE(score)</code> internal transition causes update of the score kept by the Ship. The score is not posted to the Table at this point, because the next <code>TIME_TICK</code> will send the "rounded" score, which is good enough for giving the Player the score approximation.</li>
</ul>
<ul>
<li>(9) The <code>HIT_WALL</code> event triggers transition to "exploding"</li>
</ul>
<ul>
<li>(10) The <code>HIT_MINE(type)</code> event also triggers transition to "exploding"</li>
</ul>
<ul>
<li>(11) The "exploding" state of the Ship state machine is very similar to the "exploding" state of Missile (see <a class="el" href="active_objects.html#F5s1">Figure 5-1</a>(7-9)).</li>
</ul>
<ul>
<li>(12) The <code>TIME_TICK[else]</code> transition is taken when the Ship finishes exploding. Upon this transition, the Ship object posts the event <code>GAME_OVER(me-&gt;score)</code> to the Tunnel active object to terminate the game and display the final score to the Player.</li>
</ul>
<h2><a class="anchor" id="tunnel"></a>
5.3 The Tunnel Active Object</h2>
<p>The Tunnel active object has the most complex state machine, which is shown in <a class="el" href="active_objects.html#F5s3">Figure 5-3</a>. Unlike the previous state diagrams, the diagram in <a class="el" href="active_objects.html#F5s3">Figure 5-3</a> shows only the high-level of abstraction and omits a lot of details such as most entry/exit actions, internal transitions, guard conditions, or actions on transitions. Such a "zoomed out" view is always legal in the UML, because UML allows you to choose the level of detail that you want to include in your diagram.</p>
<p>The Tunnel state machine uses state hierarchy more extensively than the Ship state machine in <a class="el" href="active_objects.html#F5s2">Figure 5-2</a>. The explanation section immediately following <a class="el" href="active_objects.html#F5s3">Figure 5-3</a> illuminates the new uses of state nesting as well as the new elements not explained yet in the other state diagrams.</p>
<p><a class="anchor" id="F5s3"></a> </p>
<div align="center">
<img src="Fig1.07.jpg" alt="Fig1.07.jpg"/>
<p><strong>Figure 5-3 Tunnel state machine diagram.</strong></p></div>
 <ul>
<li>(1) An initial transition can target a substate at any level of state hierarchy, not necessarily just the next-lower level. Here the top-most initial transition goes down two levels to the substate "demo".</li>
</ul>
<ul>
<li>(2) The superstate "active" handles the <code>PLAYER_QUIT</code> event as a transition to the final state (see explanation of element (3)). Please note that the PLAYER_QUIT transition applies to all substates directly or transitively nested in the "active" superstate. Because a state transition always involves execution of all exit actions from the states, the high-level PLAYER_QUIT transition guarantees the proper cleanup that is specific to the current state context, whichever substate happens to be active at the time when the <code>PLAYER_QUIT</code> event arrives.</li>
</ul>
<ul>
<li>(3) The final state is indicated in the UML notation as the bull's-eye symbol and typically indicates destruction of the state machine object. In this case, the <code>PLAYER_QUIT</code> event indicates termination of the game.</li>
</ul>
<ul>
<li>(4) The <code>MINE_DISABLED(mine_id)</code> event is handled at the high level of the "active" state, which means that this internal transition applies to the whole sub-machine nested inside the "active" superstate. (See also the discussion of Mine object in the next section.)</li>
</ul>
<ul>
<li>(5) The entry action to the "demo" state starts the screen time event (timer) <code>me-&gt;screenTimeEvt</code> to expire in 20 seconds. Time events are allocated by the application, but they are managed by the QF framework. QF provides functions to arm a time event, such as <a class="el" href="qf_8h.html#a7091744cf5947a517782c530fceebc0c" title="Arm a one-shot time event for direct event posting.">QTimeEvt_postIn()</a> for one-shot timeout, and <a class="el" href="qf_8h.html#ac551ecf84032c1c6799734671be01894" title="Arm a periodic time event for direct event posting.">QTimeEvt_postEvery()</a> for periodic time events. Arming a time event is in effect telling the QF framework, for instance, "Give me a nudge in 20
seconds". QF then posts the time event (the event me-&gt;screenTimeEvt in this case) to the active object after the requested number of clock ticks. Chapters 6 and 7 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a> talk about time events in detail.</li>
</ul>
<ul>
<li>(6) The exit action from the "demo" state disarms the me-&gt;screenTimeEvt time event. This cleanup is necessary when the state can be exited by a different event than the time event, such as the <code>PLAYER_TRIGGER</code> transition.</li>
</ul>
<ul>
<li>(7) The <code>SCREEN_TIMEOUT</code> transition to "screen_saver" is triggered by the expiration of the me-&gt;screenTimeEvt time event. The signal <code>SCREEN_TIMEOUT</code> is assigned to this time event upon initialization and cannot be changed later.</li>
</ul>
<ul>
<li>(8) The transition triggered by <code>PLAYER_TRIGGER</code> applies equally to the two substates of the "screen_saver" superstate.</li>
</ul>
<h2><a class="anchor" id="mines"></a>
5.4 The Mine Components</h2>
<p>Mines are also modeled as hierarchical state machines, but are not active objects. Instead, Mines are components of the Tunnel active object and share its event queue and priority level. The Tunnel active object communicates with the Mine components synchronously by directly dispatching events to them via the function <a class="el" href="qep_8h.html#aa3aae49d6ee450d49a876b203db19105" title="Dispatches an event to a HSM.">QHsm_dispatch()</a>. Mines communicate with Tunnel and all other active objects asynchronously by posting events to their event queues via the function <a class="el" href="qf_8h.html#a5330bd5a4837326763be29d1047d6dd3" title="Posts an event e directly to the event queue of the acitve object me using the First-In-First-Out (FI...">QActive_postFIFO()</a>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Active objects exchange events asynchronously, meaning that the sender of the event merely posts the event to the event queue of the recipient active object without waiting for the completion of the event processing. In contrast, synchronous event processing corresponds to a function call (e.g., <a class="el" href="qep_8h.html#aa3aae49d6ee450d49a876b203db19105" title="Dispatches an event to a HSM.">QHsm_dispatch()</a>), which processes the event in the caller's thread of execution.</dd></dl>
<p><a class="anchor" id="F5s4"></a> </p>
<div align="center">
<img src="Fig1.08.jpg" alt="Fig1.08.jpg"/>
<p><strong>Figure 5-4 The Table active object manages two types of Mines.</strong></p></div>
<p> As shown in <a class="el" href="active_objects.html#F5s4">Figure 5-4</a>, Tunnel maintains the data member mines[], which is an array of pointers to hierarchical state machines (QHsm *). Each of these pointers can point either to a Mine1 object, a Mine2 object, or NULL, if the entry is unused. Please note that Tunnel "knows" the Mines only as generic state machines (pointers to the QHsm structure defined in QP). Tunnel dispatches events to Mines uniformly, without differentiating between different types of Mines. Still, each Mine state machine handles the events it its specific way. For example, Mine type 2 checks for collision with the Missile differently than with the Ship while Mine type 1 handles both identically.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The last point is actually very interesting. Dispatching the same event to different Mine objects results in different behavior, specific to the type of the Mine, which in OOP is known as polymorphism. I'll have more to say about this in Chapter 3 of <a class="el" href="index.html#PSiCC2">Practical UML Statecharts in C/C++, Second Edition</a>.</dd></dl>
<p>Each Mine object is fairly autonomous. The Mine maintains its own position and is responsible for informing the Tunnel object whenever the Mine gets destroyed or scrolls out of the display. This information is vital for the Tunnel object so that it can keep track of the unused Mines.</p>
<p><a class="el" href="active_objects.html#F5s5">Figure 5-5</a> shows a hierarchical state machine of Mine2 state machine. Mine1 is very similar, except that it uses the same bitmap for testing collisions with the Missile and the Ship.</p>
<p><a class="anchor" id="F5s5"></a> </p>
<div align="center">
<img src="Fig1.09.jpg" alt="Fig1.09.jpg"/>
<p><strong>Figure 5-5 Mine2 state machine diagram.</strong></p></div>
 <ul>
<li>(1) The Mine starts in the "unused" state.</li>
</ul>
<ul>
<li>(2) The Tunnel object plants a Mine by dispatching the <code>MINE_PLANT(x, y)</code> event to the Mine. The Tunnel provides the <code>(x, y)</code> coordinates as the original position of the Mine.</li>
</ul>
<ul>
<li>(3) When the Mine scrolls off the display the state machine transitions to "unused".</li>
</ul>
<ul>
<li>(4) When the Mine hits the Ship the state machine transitions to "unused".</li>
</ul>
<ul>
<li>(5) When the Mine scrolls finishes exploding the state machine transitions to "unused".</li>
</ul>
<ul>
<li>(6) When the Mine is recycled by the Tunnel object the state machine transitions to "unused".</li>
</ul>
<ul>
<li>(7) The exit action in the "unused" state posts the MINE_DISABLDED(mine_id) event to the Tunnel active object. Through this event, the Mine informs the Tunnel that it's becoming disabled, so that Tunnel can update its <code>mines[]</code> array (see also <a class="el" href="active_objects.html#F5s4">Figure 5-4</a>(4)). The mine_id parameter of the event becomes the index into the <code>mines[]</code> array. Please note that generating the <code>MINE_DISABLDED(mine_id)</code> event in the exit action from "used" is much safer and more maintainable than repeating this action in each individual transition (3), (4), (5), and (6).</li>
</ul>
<p>Prev: <a class="el" href="design.html">4. Designing an Event-Driven Application</a> <br/>
 Next: <a class="el" href="events.html">6. Defining Event Signals and Event Parameters</a></p>
<div align="center">
<img src="logo_ql_TM.jpg" alt="logo_ql_TM.jpg"/>
</div>
<p> Copyright &copy; 2002-2011 Quantum Leaps, LLC. All Rights Reserved.<br/>
 <a href="http://www.state-machine.com">http://www.state-machine.com</a> </p>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Apr 26 2011 09:40:34 for QP/C by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
